<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>夜</title>
  
  <subtitle>思いつけば、この一生はなにを求めているんだろう</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mxuanp.github.io/"/>
  <updated>2020-06-24T10:39:50.508Z</updated>
  <id>https://mxuanp.github.io/</id>
  
  <author>
    <name>夜</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World - 夜 - Hexo</title>
    <link href="https://mxuanp.github.io/2020/06/23/hello-world/"/>
    <id>https://mxuanp.github.io/2020/06/23/hello-world/</id>
    <published>2020-06-23T12:02:02.288Z</published>
    <updated>2020-06-24T10:39:50.508Z</updated>
    
    <content type="html"><![CDATA[<p>==================================人生的分界线==============================</p><blockquote><p>Gopaher,,,,,,,,,,,, </p></blockquote><a id="more"></a><img src= "/img/loading.gif" data-src="/2020/06/23/hello-world/gopher-power.png" class="" title="Gopher power">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;==================================人生的分界线==============================&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Gopaher,,,,,,,,,,,, &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="hello" scheme="https://mxuanp.github.io/categories/hello/"/>
    
    
      <category term="start" scheme="https://mxuanp.github.io/tags/start/"/>
    
      <category term="life" scheme="https://mxuanp.github.io/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>Go语言高级编程学习笔记-01</title>
    <link href="https://mxuanp.github.io/2020/06/21/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01/"/>
    <id>https://mxuanp.github.io/2020/06/21/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01/</id>
    <published>2020-06-21T11:13:46.000Z</published>
    <updated>2020-06-24T10:39:45.184Z</updated>
    
    <content type="html"><![CDATA[<h1 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h1><h2 id="1-Go创世纪"><a href="#1-Go创世纪" class="headerlink" title="1.Go创世纪"></a>1.Go创世纪</h2><blockquote><p>据说设计go语言最初的洪荒之力来自与几位创始人对c++11大吹特捧的复杂无比的特性的鄙视，，就是这么牛逼</p></blockquote><a id="more"></a><blockquote><p>先从图谱左边看起，这里可以明确Go的并发特性由贝尔实验室的Hoare在1978年发布的CSP理论演化而来</p></blockquote><h3 id="1-1-Actor模型"><a href="#1-1-Actor模型" class="headerlink" title="1.1 Actor模型"></a>1.1 Actor模型</h3><blockquote><p>在Actor模型中，主角是Actor，actor之间彼此发送消息，不需要经过中介，而且消息是异步发送和处理的</p></blockquote><img src= "/img/loading.gif" data-src="/2020/06/21/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01/Actor-model.png" class="" title="Actor模型"><blockquote><p>在这个模型中描述的关于避免并发编程的常见问题的公理：</p><ol><li>所有Actor的状态是本地的，外部无法访问</li><li>Actor必须通过消息传递进行通信</li><li>一个Actor可以响应消息：推出新Actor，改变其内部状态，或将消息发送到一个或多个其它参与者</li><li>Actor可能会堵塞自己，但Actor不应堵塞它运行的线程</li></ol></blockquote><h3 id="1-2-CSP模型"><a href="#1-2-CSP模型" class="headerlink" title="1.2 CSP模型"></a>1.2 CSP模型</h3><blockquote><p>在CSP模型中，worker之间不会直接通信，而是通过channel进行消息的发布和侦听消息，此时，消息发送者和消息接收者通过channel松耦合，发送者无法得知是谁消费了自己的消息，接收者也无法得知是谁发送的消息</p></blockquote><img src= "/img/loading.gif" data-src="/2020/06/21/Go%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01/Go-csp.png" class="" title="Go CSP模型"><blockquote><p>Go语言的CSP模型是由Goroutine和Channel实现</p><ul><li>goroutine是一种轻量线程，不是os的线程，而是将线程的时间片分段使用，通过调度器协作调度</li><li>Channel：类似Unix的pipe，用于协程间通信和同步，协程之间虽然解耦合，但又和channel有耦合</li></ul></blockquote><h2 id="2-数组，字符串和切片"><a href="#2-数组，字符串和切片" class="headerlink" title="2.数组，字符串和切片"></a>2.数组，字符串和切片</h2><blockquote><p>在Golang中，数组，字符串和切片的底层有着相同的结构</p></blockquote><h3 id="2-1-数组"><a href="#2-1-数组" class="headerlink" title="2.1 数组"></a>2.1 数组</h3><blockquote><p>在Golang中，数组是一种值类型，数组的元素可以修改，但是数组本身的赋值和函数传参都是一整体复制的方式处理的</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>, &amp;arr)</span><br><span class="line"></span><br><span class="line">arr1 := arr</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>, &amp;arr3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 结果如下，arr1是一个全新的变量，从arr得到的只有数据，而不是直接将arr的地址复制给arr1</span></span><br><span class="line"><span class="comment">0xc0000be000</span></span><br><span class="line"><span class="comment">0xc0000be020</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;语言基础&quot;&gt;&lt;a href=&quot;#语言基础&quot; class=&quot;headerlink&quot; title=&quot;语言基础&quot;&gt;&lt;/a&gt;语言基础&lt;/h1&gt;&lt;h2 id=&quot;1-Go创世纪&quot;&gt;&lt;a href=&quot;#1-Go创世纪&quot; class=&quot;headerlink&quot; title=&quot;1.Go创世纪&quot;&gt;&lt;/a&gt;1.Go创世纪&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;据说设计go语言最初的洪荒之力来自与几位创始人对c++11大吹特捧的复杂无比的特性的鄙视，，就是这么牛逼&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="go" scheme="https://mxuanp.github.io/categories/go/"/>
    
    
      <category term="go" scheme="https://mxuanp.github.io/tags/go/"/>
    
      <category term="golang" scheme="https://mxuanp.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go语言标准库-读书笔记-1</title>
    <link href="https://mxuanp.github.io/2020/04/15/Go%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86%E5%BA%93-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-1/"/>
    <id>https://mxuanp.github.io/2020/04/15/Go%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86%E5%BA%93-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-1/</id>
    <published>2020-04-15T07:42:51.000Z</published>
    <updated>2020-06-24T10:39:41.972Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go-strings库"><a href="#Go-strings库" class="headerlink" title="Go strings库"></a>Go strings库</h1><h2 id="strings-Join方法"><a href="#strings-Join方法" class="headerlink" title="strings.Join方法"></a>strings.Join方法</h2><a id="more"></a><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果自己实现，一般会使用bytes.Buffer来做缓冲实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Join</span><span class="params">(str []<span class="keyword">string</span>, sep <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="comment">// 特殊情况应该做处理</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(str) == <span class="number">0</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(str) == <span class="number">1</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> str[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  buffer := bytes.NewBufferString(str[<span class="number">0</span>])</span><br><span class="line">  <span class="keyword">for</span> _, s := <span class="keyword">range</span> str[<span class="number">1</span>:] &#123;</span><br><span class="line">      buffer.WriteString(sep)</span><br><span class="line">      buffer.WriteString(s)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> buffer.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//但是官方没有使用bytes，可能是不想有所依赖</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Join</span><span class="params">(elems []<span class="keyword">string</span>, sep <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> <span class="built_in">len</span>(elems) &#123;<span class="comment">//特殊情况处理</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> elems[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//计算连接后的字符串长度</span></span><br><span class="line">n := <span class="built_in">len</span>(sep) * (<span class="built_in">len</span>(elems) - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(elems); i++ &#123;</span><br><span class="line">n += <span class="built_in">len</span>(elems[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b Builder <span class="comment">//一个strings声明的类型</span></span><br><span class="line">b.Grow(n)<span class="comment">//设置builder的buf，如果builder是新声明的，Grow后buf的cap则会是n，总之Grow后，builder的buf长度最少为n</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里的写入字符串的操作，内部是用append实现，由于之前builder声明时，已经计算好了buf的长度，所以WriteString里的append操作不会有重复分配内存的情况</span></span><br><span class="line">    b.WriteString(elems[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">for</span> _, s := <span class="keyword">range</span> elems[<span class="number">1</span>:] &#123;</span><br><span class="line">b.WriteString(sep)</span><br><span class="line">b.WriteString(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Go-strings库&quot;&gt;&lt;a href=&quot;#Go-strings库&quot; class=&quot;headerlink&quot; title=&quot;Go strings库&quot;&gt;&lt;/a&gt;Go strings库&lt;/h1&gt;&lt;h2 id=&quot;strings-Join方法&quot;&gt;&lt;a href=&quot;#strings-Join方法&quot; class=&quot;headerlink&quot; title=&quot;strings.Join方法&quot;&gt;&lt;/a&gt;strings.Join方法&lt;/h2&gt;
    
    </summary>
    
    
      <category term="go" scheme="https://mxuanp.github.io/categories/go/"/>
    
    
      <category term="go" scheme="https://mxuanp.github.io/tags/go/"/>
    
      <category term="golang" scheme="https://mxuanp.github.io/tags/golang/"/>
    
      <category term="strings" scheme="https://mxuanp.github.io/tags/strings/"/>
    
  </entry>
  
  <entry>
    <title>回顾-Go类型系统</title>
    <link href="https://mxuanp.github.io/2020/04/07/%E5%9B%9E%E9%A1%BE-Go%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/"/>
    <id>https://mxuanp.github.io/2020/04/07/%E5%9B%9E%E9%A1%BE-Go%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-04-07T12:53:03.000Z</published>
    <updated>2020-06-24T10:40:01.088Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go的类型系统–review"><a href="#Go的类型系统–review" class="headerlink" title="Go的类型系统–review"></a>Go的类型系统–review</h1><blockquote><p>值的类型给编译器提供两部分信息</p><ol><li>需要分配多少内存给这个值(即值的规模)</li><li>这段内存表示什么</li></ol><a id="more"></a><p>多数内置类型，规模和表示是类型名的一部分，例如int64(8字节)，float32(4字节)，bool(1字节)</p><p>有些类型内部表示则与编译代码的机器的体系结构有关。例如，根据机器所在的体系结构，一个int可能是8字节(64位机器)，也可能是4字节(32位机器)</p></blockquote><h2 id="用户自定义类型"><a href="#用户自定义类型" class="headerlink" title="用户自定义类型"></a>用户自定义类型</h2><blockquote><p>用户声明一个新类型时，这个声明就为编译器提供了一个框架，告知必要的内存大小和表示信息</p></blockquote><h3 id="使用struct声明"><a href="#使用struct声明" class="headerlink" title="使用struct声明"></a>使用struct声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User 在程序中定义一个用户类型</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Email <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义后就可以使用 var 关键字声明</span></span><br><span class="line"><span class="keyword">var</span> user User;</span><br><span class="line"><span class="comment">//或者使用简短声明</span></span><br><span class="line">user := User&#123;<span class="string">"ye"</span>, <span class="string">"ye@email.com"</span>&#125;<span class="comment">//这种方法必须依照User声明的顺序声明值</span></span><br><span class="line"></span><br><span class="line">user := User&#123;<span class="comment">//这样声明不必按照类型中声明的顺序</span></span><br><span class="line">    Email:<span class="string">"ye@email.com"</span>，</span><br><span class="line">    Name:<span class="string">"ye"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>结构体中的字段并不限制内置类型，可以使用其他用户定义的类型</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// admin需要User作为管理者，并有相应权限</span></span><br><span class="line"><span class="keyword">type</span> Admin <span class="keyword">struct</span> &#123;</span><br><span class="line">    Person User</span><br><span class="line">    Level <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">admin := Admin&#123;</span><br><span class="line">    Person:User&#123;<span class="comment">//Person也可以按顺序不写字段名初始化</span></span><br><span class="line">        Name:<span class="string">"ye"</span>,</span><br><span class="line">        Email:<span class="string">"ye@email.com"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    Level:<span class="string">"root"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基于已有类型声明新类型"><a href="#基于已有类型声明新类型" class="headerlink" title="基于已有类型声明新类型"></a>基于已有类型声明新类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Duration <span class="keyword">int64</span> <span class="comment">//声明新类型Duration，这是time包中的一个声明。Duration用于描述时间的间隔，单位ns</span></span><br></pre></td></tr></table></figure><blockquote><p>虽然Duration的基础类型是int64，但是Go不会认为这是一种类型</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//===例子：</span></span><br><span class="line"><span class="keyword">var</span> d Duration</span><br><span class="line">d = <span class="keyword">int64</span>(<span class="number">10</span>)</span><br><span class="line"><span class="comment">//main.go:7:4: cannot use int64(10) (type int64) as type Duration in assignment</span></span><br></pre></td></tr></table></figure><blockquote><p>两种不同类型即使互相兼容，也不能相互赋值，编译器也不会做隐式赋值</p></blockquote><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><blockquote><p>方法实际上就是函数，只是多了接收者</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span>&#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    email <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u user)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;<span class="comment">//声明方法，使用值接收者</span></span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"name:%s email:%s"</span>,u.name, u.email)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span> <span class="title">change</span><span class="params">(newName <span class="keyword">string</span>)</span></span>&#123;<span class="comment">//声明方法，使用指针接收者</span></span><br><span class="line">    u.name = newName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">u := user&#123;<span class="string">"ye"</span>,<span class="string">"ye@email.com"</span>&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(u) <span class="comment">// name:ye email:ye@email.com</span></span><br><span class="line"><span class="comment">//String()实际上是Stringer定义的接口需要实现的函数，fmt包下的很多函数会使用Stringer接口打印值</span></span><br><span class="line"></span><br><span class="line">u.change(<span class="string">"golang"</span>) <span class="comment">//编译器会转换为 (&amp;u).change("golang")</span></span><br><span class="line"><span class="built_in">println</span>(u.name) <span class="comment">//golang</span></span><br><span class="line"></span><br><span class="line">nu := &amp;u</span><br><span class="line">nu.String() <span class="comment">//编译器会转换为 (*nu).String()</span></span><br></pre></td></tr></table></figure><blockquote><p>调用时使用指针或是值都没关系，编译器会做转换，但是接收者为值接收者，那么就会创建一个值副本，是没有办法改变调用者的值的，使用指针则可以改变值</p><p>实际上指针接收者也是创建值副本，只是创建的是指针的副本，因而可以改变指针指向的内存块的数据</p></blockquote><h2 id="类型的本质"><a href="#类型的本质" class="headerlink" title="类型的本质"></a>类型的本质</h2><blockquote><p>声明一个新类型的方法前，应思考：这个类型的本质是什么？如果给这个类型增加或删除值，是要创建新值，还是更改当前值？</p><p>如果是前者，就该使用值接收者，如果是后者就使用指针接收者。</p><p>这个答案还会影响到程序内部传递这个类型的方式：是按值传递，还是指针传递。保持传递的一致性是很重要的。</p></blockquote><h3 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h3><blockquote><p>内置类型即数值类型，字符串类型，布尔类型。这些类型本质上是原始类型，因而对这些值进行删除或修改，会创建新的值</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//package strings // import "strings 这是sgrings包下的Trim函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Trim</span><span class="params">(s <span class="keyword">string</span>, cutset <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">""</span> || cutset == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TrimFunc(s, makeCutsetFunc(cutset))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>string本质上是一种原始的数据值，本身不应修改，因而传递string的副本</p></blockquote><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><blockquote><p>Go的引用类型：切片，映射，通道，接口，函数。声明上述类型，创建的变量成为标头(header)值。</p><p>PS：从技术细节来说，string也是引用类型</p><p>每个引用类型包含一个指向底层数据结构的指针，每个引用类型还包含一组独特的字段，用于管理底层数据结构</p><p>标头值是为复制设计的，因而不需要共享一个引用的值，所以对于引用类型，只需要值传递(除非你需要改变这个引用本身，即改变指针的指向)</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package net // import "net" net包下IP类型的声明</span></span><br><span class="line"><span class="keyword">type</span> IP []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ip IP)</span> <span class="title">MarshalText</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(ip) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">byte</span>(<span class="string">""</span>), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(ip) != IPv4len &amp;&amp; <span class="built_in">len</span>(ip) != IPv6len &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, &amp;AddrError&#123;Err: <span class="string">"invalid IP address"</span>, Addr: hexString(ip)&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">byte</span>(ip.String()), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构类型"><a href="#结构类型" class="headerlink" title="结构类型"></a>结构类型</h3><blockquote><p>结构类型用来描述一组数据，这组数据可以是原始的，也可以是非原始的</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package time // import "time" time包下的Time结构体</span></span><br><span class="line"><span class="keyword">type</span> Time <span class="keyword">struct</span> &#123;</span><br><span class="line">wall <span class="keyword">uint64</span></span><br><span class="line">ext  <span class="keyword">int64</span></span><br><span class="line">loc *Location</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>像时间这样的值，应该思考到给定的时间点是不可以修改的，所以可以看到大多数Time的方法都是以值接收者的方式</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Date</span><span class="params">(year <span class="keyword">int</span>, month Month, day, hour, min, sec, nsec <span class="keyword">int</span>, loc *Location)</span> <span class="title">Time</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Now</span><span class="params">()</span> <span class="title">Time</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Parse</span><span class="params">(layout, value <span class="keyword">string</span>)</span> <span class="params">(Time, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseInLocation</span><span class="params">(layout, value <span class="keyword">string</span>, loc *Location)</span> <span class="params">(Time, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unix</span><span class="params">(sec <span class="keyword">int64</span>, nsec <span class="keyword">int64</span>)</span> <span class="title">Time</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Add</span><span class="params">(d Duration)</span> <span class="title">Time</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">AddDate</span><span class="params">(years <span class="keyword">int</span>, months <span class="keyword">int</span>, days <span class="keyword">int</span>)</span> <span class="title">Time</span></span></span><br></pre></td></tr></table></figure><blockquote><p>大多数情况下，结构体的本质并不是原始的，需要修改值时，在程序其他地方，需要使用指针来共享这个值</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> File <span class="keyword">struct</span>&#123;</span><br><span class="line">    *file</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//file是*File的实际表示</span></span><br><span class="line"><span class="comment">//额外的File来包裹是为了保证没有哪个os</span></span><br><span class="line"><span class="comment">//客户端可以重写这些数据。如果重写了，可能导致最终变量终结的时候关闭错误的文件描述符</span></span><br><span class="line"><span class="keyword">type</span> file <span class="keyword">struct</span> &#123;</span><br><span class="line">        pfd         poll.FD</span><br><span class="line">        name        <span class="keyword">string</span></span><br><span class="line">        dirinfo     *dirInfo <span class="comment">// nil unless directory being read</span></span><br><span class="line">        nonblock    <span class="keyword">bool</span>     <span class="comment">// whether we set nonblocking mode</span></span><br><span class="line">        stdoutOrErr <span class="keyword">bool</span>     <span class="comment">// whether this is stdout or stderr</span></span><br><span class="line">        appendMode  <span class="keyword">bool</span>     <span class="comment">// whether file is opened for appending</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(file *File, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> OpenFile(name, O_RDONLY, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一般而言，像Open这样的创建用的工厂函数，返回了一个指针，就表示这个被返回的值的本质是非原始的</p></blockquote><blockquote><p>即使函数或方法没有直接改变非原始的值的状态，仍应使用共享的方式传递</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Chdir</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := f.checkValid(<span class="string">"chdir"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> e := f.pfd.Fchdir(); e != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> f.wrapErr(<span class="string">"chdir"</span>, e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>chdir并没有去改变File的值，但是还是使用指针接收者。因为File类型的值具备非原始的本质，所以总是应该被共享，而不是被复制。</p></blockquote><blockquote><p>使用值接收者还是指针接收者，取决于类型的本质，而不是是否改变了值。</p><p>但是也有例外，即类型需要实现接口时。</p></blockquote><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><blockquote><p>多态：代码根据类型的具体实现采取不同行为的能力。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> notifier <span class="keyword">interface</span> &#123;</span><br><span class="line">notify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">email <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span> <span class="title">notify</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"sending user email to %s&lt;%s&gt;\n"</span>, u.name, u.email)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">u := user&#123; <span class="string">"ye"</span>, <span class="string">"ye@email.com"</span> &#125;</span><br><span class="line"></span><br><span class="line">sendNotify(u)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendNotify</span><span class="params">(n notifier)</span></span> &#123;</span><br><span class="line">n.notify()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p># command-line-arguments<br>./main.go:24:12: cannot use u (type user) as type notifier in argument to sendNotify:<br>    user does not implement notifier (notify method has pointer receiver)</p><p>上面的代码会编译出错，而原因也很清楚 <code>notify method has pointer receiver</code> </p></blockquote><blockquote><p>Go语言里的方法集的规则</p></blockquote><table><thead><tr><th>Values</th><th>Method Receivers</th></tr></thead><tbody><tr><td>T</td><td>(t T)</td></tr><tr><td>*T</td><td>(t T) and (t *T)</td></tr></tbody></table><blockquote><p>从这个表就可以看出，值接收者，value可以是值，也可以是指针，但是指针接收者的value只可以是指针</p><p>为什么有这个限制？因为编译器并不能总是自动获取到一个值的地址</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> duration <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *duration)</span> <span class="title">pretty</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">"Duration: %d"</span>, *d)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        duration(<span class="number">2</span>).pretty()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p># command-line-arguments<br>./main.go:10:13: cannot call pointer method on duration(2)<br>./main.go:10:13: cannot take the address of duration(2)</p><p>这是一种情况</p></blockquote><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> notifier <span class="keyword">interface</span> &#123;</span><br><span class="line">notify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">email <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> admin <span class="keyword">struct</span> &#123;</span><br><span class="line">   name <span class="keyword">string</span></span><br><span class="line">    email <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *admin)</span> <span class="title">notify</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Printf(<span class="string">"sending admin email to %s&lt;%s&gt;\n"</span>, a.name, a.email)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span> <span class="title">notify</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"sending user email to %s&lt;%s&gt;\n"</span>, u.name, u.email)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">u := user&#123; <span class="string">"ye"</span>, <span class="string">"ye@email.com"</span> &#125;</span><br><span class="line">sendNotify(u)</span><br><span class="line">    </span><br><span class="line">    a := admin&#123;<span class="string">"admin"</span>, <span class="string">"admin@email.com"</span>&#125;</span><br><span class="line">    sendNotify(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendNotify</span><span class="params">(n notifier)</span></span> &#123;</span><br><span class="line">n.notify()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Go的类型系统–review&quot;&gt;&lt;a href=&quot;#Go的类型系统–review&quot; class=&quot;headerlink&quot; title=&quot;Go的类型系统–review&quot;&gt;&lt;/a&gt;Go的类型系统–review&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;值的类型给编译器提供两部分信息&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要分配多少内存给这个值(即值的规模)&lt;/li&gt;
&lt;li&gt;这段内存表示什么&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="go" scheme="https://mxuanp.github.io/categories/go/"/>
    
    
      <category term="go" scheme="https://mxuanp.github.io/tags/go/"/>
    
      <category term="golang" scheme="https://mxuanp.github.io/tags/golang/"/>
    
      <category term="review" scheme="https://mxuanp.github.io/tags/review/"/>
    
  </entry>
  
  <entry>
    <title>go-slice</title>
    <link href="https://mxuanp.github.io/2020/03/20/go-slice/"/>
    <id>https://mxuanp.github.io/2020/03/20/go-slice/</id>
    <published>2020-03-20T12:51:59.000Z</published>
    <updated>2020-06-24T10:39:17.320Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go的切片"><a href="#Go的切片" class="headerlink" title="Go的切片"></a>Go的切片</h1><a id="more"></a><blockquote><p>go的切片(slice)是对底层数组的抽象，并提供相关的方法</p><p>slice包含三个字段的数据结构，分别是：</p><ul><li>指向底层数组的指针</li><li>长度</li><li>容量</li></ul></blockquote><img src= "/img/loading.gif" data-src="/2020/03/20/go-slice/slice.png" class="" title="slice的底层结构"><h2 id="Slice的创建"><a href="#Slice的创建" class="headerlink" title="Slice的创建"></a>Slice的创建</h2><ul><li>使用make</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span> ,<span class="number">5</span>)</span><br><span class="line"><span class="comment">//注意：3指的是长度，5指的是容量，容量不可以比长度小</span></span><br></pre></td></tr></table></figure><ul><li>使用切片字面量</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">//创建长度和容量都为3的切片</span></span><br></pre></td></tr></table></figure><ul><li>使用切片索引</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">99</span>:<span class="number">233</span>&#125; <span class="comment">//创建长度容量都是100的切片，并且初始化第100个元素为233</span></span><br></pre></td></tr></table></figure><h3 id="创建nil和空切片"><a href="#创建nil和空切片" class="headerlink" title="创建nil和空切片"></a>创建nil和空切片</h3><ul><li>nil切片</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="keyword">int</span> <span class="comment">//使用var声明一个切片，为nil</span></span><br></pre></td></tr></table></figure><ul><li>空切片</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">slice := []<span class="keyword">int</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="使用切片创建切片"><a href="#使用切片创建切片" class="headerlink" title="使用切片创建切片"></a>使用切片创建切片</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>， <span class="number">50</span>&#125;</span><br><span class="line"></span><br><span class="line">newSlice := slice[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">//切片支持的切片操作</span></span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-src="/2020/03/20/go-slice/slice2.png" class="" title="slice的切片操作"><blockquote><p>这里，切片操作后，newSlice和slice共享了一段底层数组，所以如果newSlice如果对数组中的值进行了写操作，slice相应的值也会改变</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>， <span class="number">50</span>&#125;</span><br><span class="line"></span><br><span class="line">newSlice := slice[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">newSlice[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"><span class="built_in">println</span>(slice[<span class="number">1</span>]) <span class="comment">//结果为1，而不是20</span></span><br></pre></td></tr></table></figure><h2 id="Append-slice"><a href="#Append-slice" class="headerlink" title="Append slice"></a>Append slice</h2><blockquote><p>Append时，如果底层数组的长度不足，就会创建新的数组</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>&#125;</span><br><span class="line"></span><br><span class="line">newSlice = <span class="built_in">append</span>(slice, <span class="number">50</span>)</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-src="/2020/03/20/go-slice/slice3.png" class="" title="slice的append操作"><h2 id="使用三个索引创建切片"><a href="#使用三个索引创建切片" class="headerlink" title="使用三个索引创建切片"></a>使用三个索引创建切片</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">newSlice := slice[<span class="number">2</span>:<span class="number">3</span>:<span class="number">4</span>]</span><br><span class="line"><span class="built_in">println</span>(<span class="built_in">len</span>(newSlice))<span class="comment">//1</span></span><br><span class="line"><span class="built_in">println</span>(<span class="built_in">cap</span>(newSlice))<span class="comment">//2</span></span><br><span class="line"><span class="comment">//这是怎么回事？...</span></span><br><span class="line"><span class="comment">//对于slice[i:j:k]</span></span><br><span class="line"><span class="comment">//长度：j-i ==&gt;3-2=1</span></span><br><span class="line"><span class="comment">//容量：k-i ==&gt;4-2=2</span></span><br><span class="line"><span class="comment">//这里如果 k&gt;len(slice) 会报错 slice bounds out of range...毕竟实在原来的slice切片</span></span><br></pre></td></tr></table></figure><h2 id="将一个切片append到另一个切片"><a href="#将一个切片append到另一个切片" class="headerlink" title="将一个切片append到另一个切片"></a>将一个切片append到另一个切片</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">slice2 := []<span class="keyword">int</span>&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</span><br><span class="line">slice3 = <span class="built_in">append</span>(slice, slice2...)</span><br><span class="line"><span class="comment">//这里需要使用 ...</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Go的切片&quot;&gt;&lt;a href=&quot;#Go的切片&quot; class=&quot;headerlink&quot; title=&quot;Go的切片&quot;&gt;&lt;/a&gt;Go的切片&lt;/h1&gt;
    
    </summary>
    
    
      <category term="go" scheme="https://mxuanp.github.io/categories/go/"/>
    
    
      <category term="go" scheme="https://mxuanp.github.io/tags/go/"/>
    
      <category term="golang" scheme="https://mxuanp.github.io/tags/golang/"/>
    
      <category term="slice" scheme="https://mxuanp.github.io/tags/slice/"/>
    
  </entry>
  
  <entry>
    <title>go-工具</title>
    <link href="https://mxuanp.github.io/2020/03/15/go-%E5%B7%A5%E5%85%B7/"/>
    <id>https://mxuanp.github.io/2020/03/15/go-%E5%B7%A5%E5%85%B7/</id>
    <published>2020-03-15T12:02:00.000Z</published>
    <updated>2020-06-24T10:39:31.828Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go的工具"><a href="#Go的工具" class="headerlink" title="Go的工具"></a>Go的工具</h1><a id="more"></a><blockquote><p>go本身带的工具，如果在goland这样的ide下，没有必要，但是有些时候只是需要vim之类的写个小项目，不想开ide，那么go自带的工具就有用了</p></blockquote><h2 id="Go-vet"><a href="#Go-vet" class="headerlink" title="Go vet"></a>Go vet</h2><blockquote><p>go vet会捕获一些语法错误</p></blockquote><ul><li>Printf类函数调用时，类型匹配占位符错误</li><li>定义常用的方法时，方法签名的错误</li><li>错误的结构体标签</li><li>没有指定字段名的结构体字面量</li></ul><h2 id="Go-fmt"><a href="#Go-fmt" class="headerlink" title="Go fmt"></a>Go fmt</h2><blockquote><p>将源代码格式化成Go原码类似的风格</p></blockquote><h2 id="Go-doc"><a href="#Go-doc" class="headerlink" title="Go doc"></a>Go doc</h2><blockquote><p>查看包的信息</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go doc fmt <span class="comment"># 这样就可以查看fmt包的信息</span></span><br></pre></td></tr></table></figure><h2 id="godoc"><a href="#godoc" class="headerlink" title="godoc"></a>godoc</h2><blockquote><p>go doc 的浏览器版本</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">godoc -http=:8080 <span class="comment">#本地端口8080的服务器</span></span><br></pre></td></tr></table></figure><blockquote><p>对于自己的包只要遵守规范，也可以生成到godoc，具体查看golang documention</p></blockquote><p>more ………..</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Go的工具&quot;&gt;&lt;a href=&quot;#Go的工具&quot; class=&quot;headerlink&quot; title=&quot;Go的工具&quot;&gt;&lt;/a&gt;Go的工具&lt;/h1&gt;
    
    </summary>
    
    
      <category term="go" scheme="https://mxuanp.github.io/categories/go/"/>
    
    
      <category term="go" scheme="https://mxuanp.github.io/tags/go/"/>
    
      <category term="golang" scheme="https://mxuanp.github.io/tags/golang/"/>
    
      <category term="go-tool" scheme="https://mxuanp.github.io/tags/go-tool/"/>
    
      <category term="vim" scheme="https://mxuanp.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="https://mxuanp.github.io/2020/03/04/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://mxuanp.github.io/2020/03/04/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2020-03-04T09:33:43.000Z</published>
    <updated>2020-06-24T10:40:04.424Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序算法-ヽ-✿ﾟ▽ﾟ-ノ"><a href="#排序算法-ヽ-✿ﾟ▽ﾟ-ノ" class="headerlink" title="排序算法===ヽ(✿ﾟ▽ﾟ)ノ====="></a>排序算法===ヽ(✿ﾟ▽ﾟ)ノ=====</h1><a id="more"></a><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a><a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">计数排序</a></h2><blockquote><p>计数排序使用一个额外的数组 C ，其中第i个元素是待排序数组 A 中值等于 i 的元素的个数。然后根据数组 C 来将 A 中的元素排到正确的位置。</p></blockquote><blockquote><p>通俗地理解，例如有10个年龄不同的人，统计出有8个人的年龄比A小，那A的年龄就排在第9位，用这个方法可以得到其他每个人的位置，也就排好了序。当然，年龄有重复时需要特殊处理（保证稳定性），这就是为什么最后要反向填充目标数组，以及将每个数字的统计减去1。算法的步骤如下：</p><ol><li>找出待排序的数组中最大和最小的元素</li><li>统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项</li><li>对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加）</li><li>反向填充目标数组：将每个元素 i 放在新数组的第 C[i] 项，每放一个元素就将 C[i] 减去1</li></ol></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CountSort 计数排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CountSort</span><span class="params">(src []<span class="keyword">int</span>)</span> []<span class="title">int</span></span>&#123;</span><br><span class="line">max_num := <span class="built_in">len</span>(src)</span><br><span class="line"><span class="keyword">for</span> _,v := <span class="keyword">range</span> src&#123;</span><br><span class="line"><span class="keyword">if</span> max_num &lt; v&#123;</span><br><span class="line">max_num=v</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">temp := <span class="built_in">make</span>([]<span class="keyword">int</span>, max_num)</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> src&#123;</span><br><span class="line">temp[v]++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">index := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;max_num;i++&#123;</span><br><span class="line"><span class="keyword">if</span>(temp[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">temp[i]--</span><br><span class="line">src[index]=i</span><br><span class="line">i--</span><br><span class="line">index++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> src</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;排序算法-ヽ-✿ﾟ▽ﾟ-ノ&quot;&gt;&lt;a href=&quot;#排序算法-ヽ-✿ﾟ▽ﾟ-ノ&quot; class=&quot;headerlink&quot; title=&quot;排序算法===ヽ(✿ﾟ▽ﾟ)ノ=====&quot;&gt;&lt;/a&gt;排序算法===ヽ(✿ﾟ▽ﾟ)ノ=====&lt;/h1&gt;
    
    </summary>
    
    
      <category term="go" scheme="https://mxuanp.github.io/categories/go/"/>
    
    
      <category term="go" scheme="https://mxuanp.github.io/tags/go/"/>
    
      <category term="golang" scheme="https://mxuanp.github.io/tags/golang/"/>
    
      <category term="algorithm" scheme="https://mxuanp.github.io/tags/algorithm/"/>
    
      <category term="算法" scheme="https://mxuanp.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="sort" scheme="https://mxuanp.github.io/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>go-websocket</title>
    <link href="https://mxuanp.github.io/2020/02/22/go-websocket/"/>
    <id>https://mxuanp.github.io/2020/02/22/go-websocket/</id>
    <published>2020-02-22T06:16:27.000Z</published>
    <updated>2020-06-24T10:39:24.644Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="go" scheme="https://mxuanp.github.io/categories/go/"/>
    
    
      <category term="go" scheme="https://mxuanp.github.io/tags/go/"/>
    
      <category term="golang" scheme="https://mxuanp.github.io/tags/golang/"/>
    
      <category term="websocket" scheme="https://mxuanp.github.io/tags/websocket/"/>
    
  </entry>
  
  <entry>
    <title>Docker学习&amp;使用</title>
    <link href="https://mxuanp.github.io/2020/02/03/Docker%E5%AD%A6%E4%B9%A0-%E4%BD%BF%E7%94%A8/"/>
    <id>https://mxuanp.github.io/2020/02/03/Docker%E5%AD%A6%E4%B9%A0-%E4%BD%BF%E7%94%A8/</id>
    <published>2020-02-03T05:10:52.000Z</published>
    <updated>2020-06-24T10:38:20.100Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker的学习-amp-使用"><a href="#Docker的学习-amp-使用" class="headerlink" title="Docker的学习&amp;使用"></a>Docker的学习&amp;使用</h1><blockquote><p>Docker：开源应用容器引擎，基于Go， 17.03后分为社区版和企业版</p></blockquote><a id="more"></a><h2 id="Debian安装Docker"><a href="#Debian安装Docker" class="headerlink" title="Debian安装Docker"></a>Debian安装Docker</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Debian stretch ======基本通用.....（*＾-＾*）=============</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可能需要梯子加快速度。。。ㄟ( ▔, ▔ )ㄏ proxychains</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加key</span></span><br><span class="line">curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加docker的库</span></span><br><span class="line">sudo add-apt-repository <span class="string">"deb [arch=amd64] https://download.docker.com/linux/debian <span class="variable">$(lsb_release -cs)</span> stable"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># install</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试一下</span></span><br><span class="line">sudo docker run hello-world</span><br><span class="line"><span class="comment"># 有以下信息则成功了。。。</span></span><br><span class="line"><span class="comment"># Unable to find image 'hello-world:latest' locally</span></span><br><span class="line"><span class="comment"># latest: Pulling from library/hello-world</span></span><br><span class="line"><span class="comment"># ............</span></span><br><span class="line"><span class="comment"># Status: Downloaded newer image for hello-world:latest</span></span><br><span class="line"><span class="comment"># Hello from Docker!</span></span><br><span class="line"><span class="comment"># .............</span></span><br></pre></td></tr></table></figure><h2 id="镜像加速。。。"><a href="#镜像加速。。。" class="headerlink" title="镜像加速。。。"></a>镜像加速。。。</h2><blockquote><p>没梯子用这个。。。(๑•̀ㅂ•́)و✧…===================</p></blockquote><blockquote><p>debian 8+使用</p><p>vim /etc/docker/daemon.json </p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"registry-mirrors"</span>:[<span class="string">"https://registry.docker-cn.com"</span>]&#125;</span><br></pre></td></tr></table></figure><blockquote><p>重启docker服务</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"><span class="comment"># 检查一下</span></span><br><span class="line">sudo docker info | grep https://</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="comment"># WARNING: No swap limit support</span></span><br><span class="line"><span class="comment">#  Registry: https://index.docker.io/v1/</span></span><br><span class="line"><span class="comment">#   https://registry.docker-cn.com/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有这个结果就是失败了，，，，，</span></span><br></pre></td></tr></table></figure><h2 id="容器的使用"><a href="#容器的使用" class="headerlink" title="容器的使用"></a>容器的使用</h2><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker pull 镜像名:tag</span></span><br><span class="line">docker pull ubuntu</span><br><span class="line"><span class="comment"># tag默认 latest</span></span><br></pre></td></tr></table></figure><h3 id="启动镜像"><a href="#启动镜像" class="headerlink" title="启动镜像"></a>启动镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ubuntu /bin/bash</span><br><span class="line"><span class="comment"># -i 交互式操作</span></span><br><span class="line"><span class="comment"># -t 终端</span></span><br><span class="line"><span class="comment"># /bin/bash 启动镜像运行的命令， 这里使用bash shell</span></span><br></pre></td></tr></table></figure><h3 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name ubuntu1 ubuntu /bin/bash</span><br><span class="line"><span class="comment"># -d 指定容器运行模式</span></span><br><span class="line"><span class="comment"># --name 指定容器名字</span></span><br><span class="line"><span class="comment"># 这个命令会打印一个容器id</span></span><br></pre></td></tr></table></figure><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker start &lt;容器ID&gt;</span></span><br><span class="line">docker start 5f52c8ce6964</span><br></pre></td></tr></table></figure><h3 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker restart &lt;容器ID&gt;</span></span><br><span class="line">docker restart 5f52c8ce6964</span><br></pre></td></tr></table></figure><h3 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker stop 容器id</span></span><br><span class="line">docker stop &lt;容器ID&gt;</span><br></pre></td></tr></table></figure><h3 id="进入在后台的容器"><a href="#进入在后台的容器" class="headerlink" title="进入在后台的容器"></a>进入在后台的容器</h3><ul><li>docker attach    ====&gt; 使用这个命令，在退出容器后，容器会停止</li><li>docker exec       ====&gt; 使用这个命令，退出容器后， 容器不会停止</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker attach &lt;容器ID&gt;</span></span><br><span class="line">docker attach 5f52c8ce6964</span><br><span class="line"><span class="comment"># 5f52c8ce6964是一个我本地ubuntu的镜像</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># docker exec -it &lt;容器ID&gt; /bin/bash</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 5f52c8ce6964 /bin/bash</span><br></pre></td></tr></table></figure><h3 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker export &lt;容器ID&gt; &gt; &lt;name&gt;.tar</span></span><br><span class="line">docker <span class="built_in">export</span> 5f52c8ce6964 &gt; ubuntu.tar</span><br></pre></td></tr></table></figure><h3 id="导入容器"><a href="#导入容器" class="headerlink" title="导入容器"></a>导入容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker import &lt;name&gt;.tar &lt;name&gt;:&lt;tag&gt;</span></span><br><span class="line">docker import ubuntu.tar ubuntu1:v1</span><br></pre></td></tr></table></figure><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker rm -f &lt;容器ID&gt;</span></span><br><span class="line">docker rm -f 5f52c8ce6964</span><br></pre></td></tr></table></figure><p>……….</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker --<span class="built_in">help</span></span><br><span class="line"><span class="comment"># docker &lt;command&gt; --help</span></span><br><span class="line">docker images --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><h2 id="Docker容器连接"><a href="#Docker容器连接" class="headerlink" title="Docker容器连接"></a>Docker容器连接</h2><h3 id="网络端口映射"><a href="#网络端口映射" class="headerlink" title="网络端口映射"></a>网络端口映射</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动一个webapp</span></span><br><span class="line">docker run -d -P training/webapp python app.py</span><br><span class="line"><span class="comment"># -P 容器内部端口随机映射到主机高端口</span></span><br><span class="line"><span class="comment"># -p 容器内部端口映射到指定的主机端口</span></span><br><span class="line">docker run -d -p 5000:5000 training/webapp python app.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定容器绑定的网络地址</span></span><br><span class="line">docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果要绑定udp端口</span></span><br><span class="line">docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">docker port</span><br></pre></td></tr></table></figure><h3 id="Docker互联"><a href="#Docker互联" class="headerlink" title="Docker互联"></a>Docker互联</h3><h3 id="新建网络"><a href="#新建网络" class="headerlink" title="新建网络"></a>新建网络</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d bridge <span class="built_in">test</span>-net</span><br><span class="line"><span class="comment"># -d 指定Docker网络类型， 有bridge， overlay</span></span><br></pre></td></tr></table></figure><h3 id="连接容器"><a href="#连接容器" class="headerlink" title="连接容器"></a>连接容器</h3><p> 运行一个容器并连接到新建的网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name test1 --network <span class="built_in">test</span>-net ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>再来一个</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name test2 --network <span class="built_in">test</span>-net ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>测试一下是否连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it test1 /bin/bash <span class="comment"># 进入容器test1</span></span><br><span class="line">ping test2 <span class="comment"># 可能没有ping ， 安装一下就好 apt-get update &amp; apt-get install iputils-ping</span></span><br><span class="line"><span class="comment"># 有以下结果则是成功</span></span><br><span class="line"><span class="comment"># 64 bytes from test2.test-net (172.18.0.3): icmp_seq=1 ttl=64 time=0.196 ms</span></span><br><span class="line"><span class="comment"># 64 bytes from test2.test-net (172.18.0.3): icmp_seq=2 ttl=64 time=0.091 ms</span></span><br></pre></td></tr></table></figure><h2 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a><a href="https://yeasy.gitbooks.io/docker_practice/content/image/dockerfile/" target="_blank" rel="noopener">DockerFile</a></h2><p>先来个栗子。。。。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir dockerfile &amp; <span class="built_in">cd</span> dockerfile</span><br><span class="line">vim DockerFile</span><br><span class="line"><span class="comment"># 添加以下内容</span></span><br></pre></td></tr></table></figure><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'这是一个本地构建的nginx镜像'</span> &gt; /usr/share/nginx/html/index.html</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建镜像</span></span><br><span class="line">docker build -t nginx:<span class="built_in">test</span> .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 成功结果</span></span><br><span class="line"><span class="comment"># 。。。。。。</span></span><br><span class="line"><span class="comment"># Successfully built 20688a4eb21c</span></span><br><span class="line"><span class="comment"># Successfully tagged nginx:v1</span></span><br><span class="line"></span><br><span class="line">docker images <span class="comment">#查看一下是否已有镜像</span></span><br></pre></td></tr></table></figure><h3 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM  指定基础镜像"></a>FROM  指定基础镜像</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> mysql</span><br></pre></td></tr></table></figure><blockquote><p>特殊镜像：scratch</p><p>scratch是个空白镜像， 没有任何东西，如果可执行文件不需要以系统为基础，那么使用这个镜像可以使得最后的包体积更小</p></blockquote><h3 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h3><blockquote><p>格式：</p><ul><li>RUN &lt;命令&gt;    ======= 就像shell中直接输入命令</li><li>RUN [“可执行文件”， “参数1”， “参数2”] =========更像调用函数</li></ul></blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian:scratch</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install gcc</span></span><br></pre></td></tr></table></figure><blockquote><p>dockerfile每一个指令执行后都会新建立一层，这样会产生多层镜像，造成镜像臃肿多层</p><p>所以许多命令可以一起执行</p></blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian:scratch</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install gcc -y</span></span><br></pre></td></tr></table></figure><h3 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a>COPY 复制文件</h3><blockquote><p>格式</p><ul><li>COPY [–chown=<user>:<group>] &lt;源路径&gt;… &lt;目标路径&gt;</li><li>COPY [–chown=<user>:<group>] [“&lt;源路径1&gt;”,… “&lt;目标路径&gt;”]</li></ul></blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> package.json /usr/src/app</span></span><br></pre></td></tr></table></figure><blockquote><p>源路径可以有多个，可以是通配符</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY *.conf /usr/src/app/conf/</span><br></pre></td></tr></table></figure><blockquote><p>&lt;目标路径&gt; 可以是绝对路径，也可以是相对路径</p><p>PS：相对路径查看 WROKDIR</p></blockquote><blockquote><p>–chown=<user>:<group> 用来改变文件属性和用户组</p></blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> --chown=777:mygroup *.js /usr/src/app/</span></span><br></pre></td></tr></table></figure><h3 id="ADD-更高级的复制文件"><a href="#ADD-更高级的复制文件" class="headerlink" title="ADD 更高级的复制文件"></a>ADD 更高级的复制文件</h3><blockquote><p>ADD和COPY的格式一致，功能更加高级</p><ul><li>&lt;源路径&gt;可以是 <code>URL</code> </li><li>&lt;源路径&gt;为tar压缩文件时，ADD会自动解压到&lt;目标路径&gt;</li></ul></blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> test.tar.gz /</span></span><br></pre></td></tr></table></figure><blockquote><p>有些时候，我们希望只是复制压缩文件，而不要解压，这是就不能使用ADD， 而应使用COPY， 所以适合使用ADD的场景就是需要自动解压的时候</p><p>PS：使用ADD指令会使镜像构建缓存失效，令构建变得缓慢</p></blockquote><h3 id="CMD容器启动命令"><a href="#CMD容器启动命令" class="headerlink" title="CMD容器启动命令"></a>CMD容器启动命令</h3><blockquote><p>格式和RUN一样</p><p>CMD指定的命令会在容器启动时执行</p></blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$HOME</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际执行的时候会被替换为</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"echo <span class="variable">$HOME</span>"</span>]</span></span><br></pre></td></tr></table></figure><blockquote><p>也就是说CMD指定的命令 第一种格式最终会被替换为第二种格式 执行</p></blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> service nginx start</span></span><br><span class="line"><span class="comment"># 会被替换为</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"service nginx start"</span>]</span></span><br><span class="line"><span class="comment"># 此时主进程为 sh ， sh执行结束后容器就会退出， 而 nginx 也不会作为守护进程启动</span></span><br></pre></td></tr></table></figure><h3 id="ENTRYPOINT-入口点"><a href="#ENTRYPOINT-入口点" class="headerlink" title="ENTRYPOINT 入口点"></a>ENTRYPOINT 入口点</h3><blockquote><p>格式和RUN一样</p></blockquote><blockquote><p>ENTRYPOINT 和 CMD 一样，都是指定在容器启动时的执行命令和参数</p><p>但是有了 ENTRYPOINT 后， 会将CMD的内容作为参数传递给 ENTRYPOINT</p></blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 什么意思呢</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"curl"</span>, <span class="string">"-s"</span>, <span class="string">"https://ip.cn"</span>]</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建镜像</span></span><br><span class="line">docker build -t checkip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动镜像</span></span><br><span class="line">dcoker run checkip -i</span><br><span class="line"><span class="comment"># 此时， 这个参数 -i 不会是需要执行的命令，而是作为参数传递给 ENTRYPOINT 指定的命令</span></span><br><span class="line"><span class="comment"># 也就是说 ENTRYPOINT 最终会执行 curl -s https://ip.cn -i</span></span><br><span class="line"><span class="comment"># 如果不是使用 ENTRYPOINT 而是 CMD 那么将会执行 -i ， 但是 -i 并不是一个可执行的命令</span></span><br></pre></td></tr></table></figure><blockquote><p>而根据这个特点，可以使用 参数 指定 容器 运行的脚本</p></blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是redis官方的镜像</span></span><br><span class="line"><span class="keyword">FROM</span> alpine:<span class="number">3.4</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> addgroup -S redis &amp;&amp; adduser -S -G redis redis</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"docker-entrypoint.sh"</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">6379</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">"redis-server"</span> ]</span></span><br></pre></td></tr></table></figure><blockquote><p>此时我们就可以指定运行的脚本</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 栗子。。。。。</span></span><br><span class="line">docker run -it redis id</span><br></pre></td></tr></table></figure><h3 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h3><blockquote><p>这个比较简单， 格式</p><ul><li>ENV &lt;key&gt; &lt;value&gt;</li><li>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt; ……….</li></ul><p>使用环境变量 $<Key></p></blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> VERSION=<span class="number">1.0</span></span><br><span class="line"><span class="keyword">run</span><span class="bash"> apt-get install app-v<span class="variable">$VERSION</span></span></span><br></pre></td></tr></table></figure><h3 id="ARG-构建参数"><a href="#ARG-构建参数" class="headerlink" title="ARG 构建参数"></a>ARG 构建参数</h3><blockquote><p>格式</p><p>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</p><p>ARG和ENV一样，都是设置环境变量， 但是ARG设置的环境变量只在 docker build的时候有用， 也就是说，容器运行时，就没有这些环境变量了</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在shell指定 ARG的值</span></span><br><span class="line">docker build --build-tag &lt;参数名&gt;=&lt;值&gt; <span class="comment"># 覆盖默认值</span></span><br><span class="line"><span class="comment"># 如果Dockerfile中没有使用 ARG 指定这个参数，在1.13前会报错，之后的版本是警告</span></span><br></pre></td></tr></table></figure><h3 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h3><blockquote><p>格式</p><ul><li>VOLUME [“&lt;路径1&gt;”, “&lt;路径2&gt;”………]</li><li>VOLUME &lt;路径&gt;</li></ul></blockquote><blockquote><p>挂载一个匿名卷，任何向这个卷的写入信息都不会记录进存储层，保证容器存储层的无状态化</p></blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span><span class="bash"> /data</span></span><br></pre></td></tr></table></figure><h3 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR 指定工作目录"></a>WORKDIR 指定工作目录</h3><blockquote><p>格式</p><p>WORKDIR &lt;路径&gt;</p></blockquote><blockquote><p>指定dockerfile执行命令时所在的路径</p></blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"hello"</span> &gt; world.txt <span class="comment"># 执行这条命令时路径并不是 /app， 因为在Dockerfile中两个RUN的执行环境并不一样</span></span></span><br></pre></td></tr></table></figure><blockquote><p>所以，如果希望执行的命令所在的路径都在一个， 可以使用WORKDIR指定</p></blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br></pre></td></tr></table></figure><h3 id="USER-指定用户"><a href="#USER-指定用户" class="headerlink" title="USER 指定用户"></a>USER 指定用户</h3><blockquote><p>格式： USER &lt;用户名&gt;[:&lt;用户组&gt;]</p></blockquote><blockquote><p>使用USER切换的用户必须是已经创建的</p></blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> groupadd -r redis &amp;&amp; useradd -r -g redis redis <span class="comment">#这样就可以创建一个用户</span></span></span><br><span class="line"><span class="keyword">USER</span> redis <span class="comment"># 切换用户，以后所有命令的身份都是 redis</span></span><br></pre></td></tr></table></figure><h3 id="EXPOSE-暴露端口"><a href="#EXPOSE-暴露端口" class="headerlink" title="EXPOSE 暴露端口"></a>EXPOSE 暴露端口</h3><blockquote><p>格式： EXPOSE &lt;端口1&gt; [&lt;端口2&gt;…..]</p></blockquote><blockquote><p>EXPOSE只是声明一个容器运行时提供的端口，并不是自动开启</p><p>使用 -P 时会自动映射到EXPOSE的端口</p></blockquote><h2 id="Dockerfile多段构建"><a href="#Dockerfile多段构建" class="headerlink" title="Dockerfile多段构建"></a>Dockerfile多段构建</h2><p>TODO………..</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker的学习-amp-使用&quot;&gt;&lt;a href=&quot;#Docker的学习-amp-使用&quot; class=&quot;headerlink&quot; title=&quot;Docker的学习&amp;amp;使用&quot;&gt;&lt;/a&gt;Docker的学习&amp;amp;使用&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Docker：开源应用容器引擎，基于Go， 17.03后分为社区版和企业版&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="docker" scheme="https://mxuanp.github.io/categories/docker/"/>
    
    
      <category term="docker" scheme="https://mxuanp.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>RPC入门</title>
    <link href="https://mxuanp.github.io/2020/01/29/RPC%E5%85%A5%E9%97%A8/"/>
    <id>https://mxuanp.github.io/2020/01/29/RPC%E5%85%A5%E9%97%A8/</id>
    <published>2020-01-29T07:03:24.000Z</published>
    <updated>2020-06-24T10:39:54.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RPC入门-φ-≧ω≦-♪"><a href="#RPC入门-φ-≧ω≦-♪" class="headerlink" title="RPC入门=========φ(≧ω≦*)♪=========="></a>RPC入门=========φ(≧ω≦*)♪==========</h1><blockquote><p>RPC:远程过程调用，分布式系统中不同节点间流行的通信方式</p></blockquote><a id="more"></a><p>先来个Hello World</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HelloService <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Hello 这个方法必须满足Go的RPC的规则：方法只能有两个可序列化的参数，其中第二个是指针类型， 必须是公开的方法，即可导出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HelloService)</span> <span class="title">Hello</span><span class="params">(request <span class="keyword">string</span>, reply *<span class="keyword">string</span>)</span> <span class="title">error</span></span>&#123;</span><br><span class="line">    *reply = <span class="string">"Hello World"</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务端代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 注册RPC服务</span></span><br><span class="line">    rpc.RegisterName(<span class="string">"HelloService"</span>, <span class="built_in">new</span>(HelloService))</span><br><span class="line"></span><br><span class="line">    listener, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">":1234"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">"ListenTCP error:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    conn, err := listener.Accept()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">"Accept error:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    rpc.ServeConn(conn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端代码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    client, err := rpc.Dial(<span class="string">"tcp"</span>, <span class="string">"localhost:1234"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">"dialing:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> reply <span class="keyword">string</span></span><br><span class="line">    err = client.Call(<span class="string">"HelloService.Hello"</span>, &amp;reply)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fmt.Println(reply)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>…..TODO</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;RPC入门-φ-≧ω≦-♪&quot;&gt;&lt;a href=&quot;#RPC入门-φ-≧ω≦-♪&quot; class=&quot;headerlink&quot; title=&quot;RPC入门=========φ(≧ω≦*)♪==========&quot;&gt;&lt;/a&gt;RPC入门=========φ(≧ω≦*)♪==========&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;RPC:远程过程调用，分布式系统中不同节点间流行的通信方式&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="go" scheme="https://mxuanp.github.io/categories/go/"/>
    
    
      <category term="go" scheme="https://mxuanp.github.io/tags/go/"/>
    
      <category term="golang" scheme="https://mxuanp.github.io/tags/golang/"/>
    
      <category term="RPC" scheme="https://mxuanp.github.io/tags/RPC/"/>
    
      <category term="gRPC" scheme="https://mxuanp.github.io/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>Go-Review</title>
    <link href="https://mxuanp.github.io/2020/01/28/Go-Review/"/>
    <id>https://mxuanp.github.io/2020/01/28/Go-Review/</id>
    <published>2020-01-28T07:36:52.000Z</published>
    <updated>2020-06-24T10:39:12.372Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Gopher-查漏补缺，-进阶学习啦。。。。。"><a href="#Gopher-查漏补缺，-进阶学习啦。。。。。" class="headerlink" title="Gopher, 查漏补缺， 进阶学习啦。。。。。"></a>Gopher, 查漏补缺， 进阶学习啦。。。。。</h1><blockquote><p>Go的基础过了， 复习，以及补缺， 进阶</p></blockquote><a id="more"></a><h2 id="Go程序的入口"><a href="#Go程序的入口" class="headerlink" title="Go程序的入口"></a>Go程序的入口</h2><blockquote><p>首先， Go程序的初始化和执行总是从main.main开始。</p><p>但是， 如果有import， 则会先import包， 按顺序导入， 一个包只会导入一次 ，如果包里有init(), 则会执行init(), 如果一个文件有多个init(), 则会按顺序执行</p><p>PS：init和普通函数不同， 可以有多个</p></blockquote><img src= "/img/loading.gif" data-src="/2020/01/28/Go-Review/pro_order.png" class="" title="Go程序的执行顺序"><blockquote><p>PS：要注意的是， 在main.main执行之前， 所有代码都在一个Goroutine， 即程序主系统线程里， 所以如果某个init()里使用 go 开启了goroutine， 新的goroutine也只能在main.main之后才能执行到</p></blockquote><h2 id="Go并不强调堆，栈"><a href="#Go并不强调堆，栈" class="headerlink" title="Go并不强调堆，栈"></a>Go并不强调堆，栈</h2><blockquote><p>Go的栈是动态栈，会自行调整大小， 所以普通程序员不再需要关心栈的大小问题， 在Go的语言规范中甚至没有讲到栈，堆的概念</p></blockquote><blockquote><p>在Go1.4后，Go的动态栈是连续动态栈，类似go的slice， 好处不提， 这里有一个问题， 动态栈增长后， 需要移到新的内存空间， 这就使得栈中所有变量的内存地址改变， 也就是说，Go的指针不再是固定不变（在使用CGO的时候，c代码中不可以长期持有Go的变量的指针， 因为指针指向的地址可能已经改变）</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Gopher-查漏补缺，-进阶学习啦。。。。。&quot;&gt;&lt;a href=&quot;#Gopher-查漏补缺，-进阶学习啦。。。。。&quot; class=&quot;headerlink&quot; title=&quot;Gopher, 查漏补缺， 进阶学习啦。。。。。&quot;&gt;&lt;/a&gt;Gopher, 查漏补缺， 进阶学习啦。。。。。&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Go的基础过了， 复习，以及补缺， 进阶&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="go" scheme="https://mxuanp.github.io/categories/go/"/>
    
    
      <category term="go" scheme="https://mxuanp.github.io/tags/go/"/>
    
      <category term="golang" scheme="https://mxuanp.github.io/tags/golang/"/>
    
      <category term="review" scheme="https://mxuanp.github.io/tags/review/"/>
    
  </entry>
  
  <entry>
    <title>go-底层编程</title>
    <link href="https://mxuanp.github.io/2020/01/27/go-%E5%BA%95%E5%B1%82%E7%BC%96%E7%A8%8B/"/>
    <id>https://mxuanp.github.io/2020/01/27/go-%E5%BA%95%E5%B1%82%E7%BC%96%E7%A8%8B/</id>
    <published>2020-01-27T07:47:57.000Z</published>
    <updated>2020-06-24T10:39:38.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go的底层编程"><a href="#Go的底层编程" class="headerlink" title="Go的底层编程"></a>Go的底层编程</h1><blockquote><p>使用CGO拥抱c，，，…(*￣０￣)ノ[等等我…]====================…………….</p></blockquote><a id="more"></a><blockquote><p>PS：真正需要使用复杂且性能高的底层接口时，才使用CGO</p><p>没什么特殊需要，使用 os/exec调用子进程就行了，当然，会产生依赖</p></blockquote><h2 id="unsafe包"><a href="#unsafe包" class="headerlink" title="unsafe包"></a>unsafe包</h2><blockquote><p>底层的包，和操作系统紧密相关</p></blockquote><img src= "/img/loading.gif" data-src="/2020/01/27/go-%E5%BA%95%E5%B1%82%E7%BC%96%E7%A8%8B/gosize.png" class="" title="go的数据类型所占的字节大小"><blockquote><p>如果有一天需要丧心病狂的优化， 那么这个就有用了</p></blockquote><h2 id="cgo"><a href="#cgo" class="headerlink" title="cgo"></a>cgo</h2><p>来个栗子。。。。(๑•̀ㅂ•́)و✧……………………一个简易的压缩程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bzip2.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bzlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bz2compress</span><span class="params">(bz_stream *s, <span class="keyword">int</span> action, <span class="keyword">char</span> *in, <span class="keyword">unsigned</span> *inlen, <span class="keyword">char</span> *out, <span class="keyword">unsigned</span> *outlen)</span></span>&#123;</span><br><span class="line">    s-&gt;next_in = in;</span><br><span class="line">    s-&gt;avail_in = *inlen;</span><br><span class="line">    s-&gt;next_out = out;</span><br><span class="line">    s-&gt;avail_out = *outlen;</span><br><span class="line">    <span class="keyword">int</span> r = BZ2_bzCompress(s, action);</span><br><span class="line">    *inlen -= s-&gt;avail_in;</span><br><span class="line">    *outlen -= a-&gt;avail_out;</span><br><span class="line">    s-&gt;next_in = s-&gt;next_out = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是go的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面是给cgo使用的特殊参数， 相应的会传给c编译器</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#cgo CFLAGS: -I/usr/include</span></span><br><span class="line"><span class="comment">#cgo LDFLAGS: -L/usr/lib -lbz2</span></span><br><span class="line"><span class="comment">#include &lt;bzlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">bz_stream* bz2alloc() &#123;return calloc(1, sizeof(bz_stream));&#125;</span></span><br><span class="line"><span class="comment">int bz2compress(bz_stream *s, int action, char *in, unsigned *inlen, char *out, unsigned *outlen);</span></span><br><span class="line"><span class="comment">void bz2free(bz_stream* s)&#123;free(s);&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"C"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">    <span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> writer <span class="keyword">struct</span>&#123;</span><br><span class="line">    w io.Writer</span><br><span class="line">    stream *C.bz_stream</span><br><span class="line">    outbuf [<span class="number">64</span>*<span class="number">1024</span>]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriter</span><span class="params">(out io.Writer)</span> <span class="title">io</span>.<span class="title">WriteCloser</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> blockSize = <span class="number">9</span></span><br><span class="line">    <span class="keyword">const</span> verbosity = <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> workFactor = <span class="number">30</span></span><br><span class="line">    w := &amp;writer&#123;w: out, stream: C.bz2alloc()&#125;</span><br><span class="line">    C.BZ2_bzCompressInit(w.stream, blockSize, verbosity, workFactor)</span><br><span class="line">    <span class="keyword">return</span> w</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *writer)</span> <span class="title">Write</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, err)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> w.stream == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"closed"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> total <span class="keyword">int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(data) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        inlen, outlen := C.<span class="keyword">uint</span>(<span class="built_in">len</span>(data)), C.<span class="keyword">uint</span>(<span class="built_in">cap</span>(w.outbuf))</span><br><span class="line">        C.bz2compress(w.stream, C.BZ_RUN, (*C.char)(unsafe.Pointer(&amp;data[<span class="number">0</span>])), &amp;inlen, (*C.char)(unsafe.Pointer(&amp;w.outbuf)), &amp;outlen)</span><br><span class="line">        total += <span class="keyword">int</span>(inlen)</span><br><span class="line">        data = data[inlen:]</span><br><span class="line">        <span class="keyword">if</span> _, err := w.w.Write(w.outbuf[:outlen]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> total, err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *writer)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> w.stream == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"closed"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        C.BZ2_bzCompressEnd(w.stream)</span><br><span class="line">        C.bz2free(w.stream)</span><br><span class="line">        w.stream = <span class="literal">nil</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        inlen, outlen := C.<span class="keyword">uint</span>(<span class="number">0</span>), C.<span class="keyword">uint</span>(<span class="built_in">cap</span>(w.outbuf))</span><br><span class="line">        r := C.bz2compress(w.stream, C.BZ_FINISH, <span class="literal">nil</span>, &amp;inlen, (*C.char)(unsafe.Pointer(&amp;w.outbuf)), &amp;outlen)</span><br><span class="line">        <span class="keyword">if</span> _, err := w.w.Write(w.outbuf[:outlen]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> r == C.BZ_STREAM_END &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>PS：这里只有CGO的一小部分， 还有很多东西</p><p>又：不是必要，不需要使用，不要过早优化</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Go的底层编程&quot;&gt;&lt;a href=&quot;#Go的底层编程&quot; class=&quot;headerlink&quot; title=&quot;Go的底层编程&quot;&gt;&lt;/a&gt;Go的底层编程&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;使用CGO拥抱c，，，…(*￣０￣)ノ[等等我…]====================…………….&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="go" scheme="https://mxuanp.github.io/categories/go/"/>
    
    
      <category term="go" scheme="https://mxuanp.github.io/tags/go/"/>
    
      <category term="golang" scheme="https://mxuanp.github.io/tags/golang/"/>
    
      <category term="cgo" scheme="https://mxuanp.github.io/tags/cgo/"/>
    
  </entry>
  
  <entry>
    <title>go-反射</title>
    <link href="https://mxuanp.github.io/2020/01/26/go-%E5%8F%8D%E5%B0%84/"/>
    <id>https://mxuanp.github.io/2020/01/26/go-%E5%8F%8D%E5%B0%84/</id>
    <published>2020-01-26T04:33:14.000Z</published>
    <updated>2020-06-24T10:39:27.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go-反射"><a href="#Go-反射" class="headerlink" title="Go 反射"></a>Go 反射</h1><a id="more"></a><blockquote><p>反射：在运行时更新变量和检查它们的值，调用它们的方法和支持的内在操作，但在编译时不知道这些变量的具体类型。</p></blockquote><h2 id="reflect-Type-和-reflect-Value"><a href="#reflect-Type-和-reflect-Value" class="headerlink" title="reflect.Type 和 reflect.Value"></a>reflect.Type 和 reflect.Value</h2><blockquote><p>这应该是go的反射最重要的东西了。。。。w(ﾟДﾟ)w……….</p></blockquote><h3 id="reflect-Type-reflect-TypeOf"><a href="#reflect-Type-reflect-TypeOf" class="headerlink" title="reflect.Type, reflect.TypeOf()"></a>reflect.Type, reflect.TypeOf()</h3><blockquote><p>reflect.TypeOf 接受interface{},并返回reflect.Type</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t := reflect.TypeOf(<span class="number">3</span>) <span class="comment">// a reflect.Type</span></span><br><span class="line">fmt.Println(t.String()) <span class="comment">// "int"</span></span><br><span class="line">fmt.Println(t) <span class="comment">// "int"</span></span><br></pre></td></tr></table></figure><blockquote><p>PS：reflect.TypeOf 返回的是接口值，而不是接口类型，可以参考 <a href="https://yaya.life/2019/12/12/go-basic-接口/" target="_blank" rel="noopener">https://yaya.life/2019/12/12/go-basic-%E6%8E%A5%E5%8F%A3/</a> </p></blockquote><h3 id="reflect-Value-reflect-ValueOf"><a href="#reflect-Value-reflect-ValueOf" class="headerlink" title="reflect.Value , reflect.ValueOf()"></a>reflect.Value , reflect.ValueOf()</h3><blockquote><p>reflect.ValueOf() 接受interface{}, 返回 reflect.Value, ValueOf和TypeOf类似，但Value可以持有接口值</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v := reflect.ValueOf(<span class="number">3</span>)</span><br><span class="line">fmt.Println(v) <span class="comment">// "3"</span></span><br><span class="line">fmt.Printf(<span class="string">"%v\n"</span>, v) <span class="comment">// "3"</span></span><br><span class="line">fmt.Println(v.String()) <span class="comment">// <span class="doctag">NOTE:</span> "&lt;int Value&gt;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//v.Type() 返回类型</span></span><br><span class="line">fmt.Println(v.Type().String()) <span class="comment">// "int"</span></span><br></pre></td></tr></table></figure><blockquote><p>PS：reflect.Value 和interface{}都可以保存任意值，但空接口隐藏了值对应的表示方式和公开的方法</p></blockquote><p>来个栗子。。。(￣ε(#￣)☆╰╮o(￣皿￣///)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Any formats any value as a string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Any</span><span class="params">(value <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> formatAtom(reflect.ValueOf(value))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">formatAtom</span><span class="params">(v reflect.Value)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> v.Kind() &#123;</span><br><span class="line"><span class="keyword">case</span> reflect.Invalid:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"invalid"</span></span><br><span class="line"><span class="keyword">case</span> reflect.Int, reflect.Int16, reflect.Int32, reflect.Int64:</span><br><span class="line"><span class="keyword">return</span> strconv.FormatInt(v.Int(), <span class="number">10</span>)</span><br><span class="line"><span class="keyword">case</span> reflect.Uint, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:</span><br><span class="line"><span class="keyword">return</span> strconv.FormatUint(v.Uint(), <span class="number">10</span>)</span><br><span class="line">    <span class="comment">// ...还有其它的， 不写了</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> v.Type().String() + <span class="string">"value"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过reflect-ValueOf-修改值"><a href="#通过reflect-ValueOf-修改值" class="headerlink" title="通过reflect.ValueOf()修改值"></a>通过reflect.ValueOf()修改值</h2><blockquote><p>使用reflect.Value的CanAddr查看是否可以取地址，但是CanAddr并不代表可以修改， CanSet才代表可以修改</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="number">2</span></span><br><span class="line">a := reflect.ValueOf(<span class="number">2</span>) </span><br><span class="line">b := reflect.ValueOf(x)</span><br><span class="line">c := reflect.ValueOf(&amp;x)</span><br><span class="line">d := c.Elem()</span><br><span class="line"></span><br><span class="line">a.CanAddr() <span class="comment">// false</span></span><br><span class="line">b.CanAddr() <span class="comment">//false</span></span><br><span class="line">c.CanAddr() <span class="comment">//false</span></span><br><span class="line">d.CanAddr() <span class="comment">//true</span></span><br><span class="line">fmt.Println(d.CanAddr(), d.CanSet()) <span class="comment">// "true" "true"</span></span><br></pre></td></tr></table></figure><blockquote><p>PS：是否可以取地址的规则类似，通过指针间接地获取的reflect.Value都是可以取值的， 例如 slice的表达式 e[i] 隐式地包含一个指针， 是可取值的， 即使e不支持取值也没关系</p></blockquote><blockquote><p>改变值，先使用Addr获取一个Value返回指向变量的指针，在调用Interface()， 返回一个interface{}, 之后就可以使用断言来更新变量</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="number">2</span></span><br><span class="line">d := reflect.ValueOf(&amp;x).Elem()</span><br><span class="line">px := d.Addr().Interface().(*<span class="keyword">int</span>)  <span class="comment">// px := &amp;x</span></span><br><span class="line">*px = <span class="number">3</span></span><br><span class="line">fmt.Println(x) <span class="comment">// "3"</span></span><br></pre></td></tr></table></figure><p>也可以。。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d.Set(reflect.ValueOf(<span class="number">4</span>))</span><br><span class="line">fmt.Println(x) <span class="comment">// "4"</span></span><br></pre></td></tr></table></figure><blockquote><p>Set方法会检查是否可赋值， 上面都是int，所以可以， 如果值不一致，就会panic</p></blockquote><blockquote><p>也有很多用于基本数据类型的方法</p><p>SetInt， SetUint， SetString， SetFloat等等， ，， </p></blockquote><h2 id="获取结构体的Tag"><a href="#获取结构体的Tag" class="headerlink" title="获取结构体的Tag"></a>获取结构体的Tag</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v := reflect.ValueOf(ptr).Elem() <span class="comment">// 获取struct p的value</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>;i&lt;v.NumField();i++&#123;</span><br><span class="line">    fieldInfo := v.Type().Field(i) <span class="comment">//reflect.StructField</span></span><br><span class="line">    tag := fieldInfo.Tag<span class="comment">// reflect.StructTag</span></span><br><span class="line">    name := tag.Get(<span class="string">"tagName"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取结构体的方法"><a href="#获取结构体的方法" class="headerlink" title="获取结构体的方法"></a>获取结构体的方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMethod</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">    v := reflect.ValueOf(x)</span><br><span class="line">    t := v.Type()</span><br><span class="line">    fmt.Printf(<span class="string">"type %s\n"</span>, t)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; v.NumMethod(); i++ &#123;</span><br><span class="line">        methodType := v.Method(i).Type()</span><br><span class="line">        fmt.Printf(<span class="string">"func (%s) %s%s\n"</span>, t, t.Method(i).Name, strings.TrimPrefix(methodType.String(), <span class="string">"func"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用这个方法</span></span><br><span class="line">v.Method(i).Call(...in) <span class="comment">//调用Method的Call</span></span><br></pre></td></tr></table></figure><h2 id="最后。。。"><a href="#最后。。。" class="headerlink" title="最后。。。"></a>最后。。。</h2><blockquote><p>反射是脆弱的，难用的，且运行速度比普通代码慢1，2个量级， 且相较下没有那么安全。能不用就不用吧</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Go-反射&quot;&gt;&lt;a href=&quot;#Go-反射&quot; class=&quot;headerlink&quot; title=&quot;Go 反射&quot;&gt;&lt;/a&gt;Go 反射&lt;/h1&gt;
    
    </summary>
    
    
      <category term="go" scheme="https://mxuanp.github.io/categories/go/"/>
    
    
      <category term="go" scheme="https://mxuanp.github.io/tags/go/"/>
    
      <category term="golang" scheme="https://mxuanp.github.io/tags/golang/"/>
    
      <category term="reflect" scheme="https://mxuanp.github.io/tags/reflect/"/>
    
  </entry>
  
  <entry>
    <title>go-test</title>
    <link href="https://mxuanp.github.io/2020/01/24/go-test/"/>
    <id>https://mxuanp.github.io/2020/01/24/go-test/</id>
    <published>2020-01-24T07:31:01.000Z</published>
    <updated>2020-06-24T10:39:20.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go-测试"><a href="#Go-测试" class="headerlink" title="Go 测试"></a>Go 测试</h1><blockquote><p>美好生活从测试开始==============(๑•̀ㅂ•́)و✧========================</p></blockquote><a id="more"></a><blockquote><p>go的测试文件以*_test.go结尾，以go test运行， 不会参与go build的构建</p><p>测试函数名以Test开头， 例如</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestWriteNote</span><span class="params">(n note)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>go的测试函数分为3类， 测试函数，基准测试函数， 示例函数</p></blockquote><h2 id="测试函数"><a href="#测试函数" class="headerlink" title="测试函数"></a>测试函数</h2><blockquote><p>测试函数一定有一下签名</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestName</span><span class="params">(t *testing.T)</span></span>&#123;<span class="comment">/*...*/</span>&#125;</span><br></pre></td></tr></table></figure><p>栗子。。。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//word.go</span></span><br><span class="line"><span class="keyword">package</span> word</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> s&#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] != s[<span class="built_in">len</span>(s) - <span class="number">1</span> - i]&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//word_test.go</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestIsPalindrome</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> !IsPalindrome(<span class="string">"aksjdncas"</span>)&#123;</span><br><span class="line">        t.Error(<span class="string">`IsPalindrome("aksjdncas) = false"`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>go test =======直接这样会出错，go version 1.13.5</p><p>go test word_test.go word.go -v 这样就好了，或者把test文件放到另一个文件夹，比如test</p><p>这是go的一些问题</p></blockquote><h2 id="测试覆盖率"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a>测试覆盖率</h2><blockquote><p>go test -run=Coverage -coverprofile=c.out projectName</p><p>-coverprofile 这个标志是在代码中插入钩子来统计覆盖率（就是bool）， </p><p>如果使用-covermode=count 那么就不是bool， 而是计数，用来衡量哪些代码频繁执行</p></blockquote><h2 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h2><blockquote><p>测量程序固定负载下的性能</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//必须以Benchmark为前缀</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFunc</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>go test -bench=.</p><p>使用-bench标志，如果没有就是普通的go test</p></blockquote><h2 id="剖析，优化，（这里就比较高深了，很多时候也用不到。。。。但是真的需要优化程序的时候就很有用了。-～￣-OO-￣-ブ）"><a href="#剖析，优化，（这里就比较高深了，很多时候也用不到。。。。但是真的需要优化程序的时候就很有用了。-～￣-OO-￣-ブ）" class="headerlink" title="剖析，优化，（这里就比较高深了，很多时候也用不到。。。。但是真的需要优化程序的时候就很有用了。(～￣(OO)￣)ブ）"></a>剖析，优化，（这里就比较高深了，很多时候也用不到。。。。但是真的需要优化程序的时候就很有用了。(～￣(OO)￣)ブ）</h2><blockquote><p>go test -cpuprofile=cpu.out  -cpuprofile= 分析函数执行所需要的cpu时间</p><p>go test -blockprofile=block.out  -blockprofile 记录goroutine阻塞情况</p><p>go test -memprofile=mem.out   -memprofile= 记录内存使用情况</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Go-测试&quot;&gt;&lt;a href=&quot;#Go-测试&quot; class=&quot;headerlink&quot; title=&quot;Go 测试&quot;&gt;&lt;/a&gt;Go 测试&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;美好生活从测试开始==============(๑•̀ㅂ•́)و✧========================&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="go" scheme="https://mxuanp.github.io/categories/go/"/>
    
    
      <category term="go" scheme="https://mxuanp.github.io/tags/go/"/>
    
      <category term="golang" scheme="https://mxuanp.github.io/tags/golang/"/>
    
      <category term="test" scheme="https://mxuanp.github.io/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>go-并发编程</title>
    <link href="https://mxuanp.github.io/2020/01/23/go-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>https://mxuanp.github.io/2020/01/23/go-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</id>
    <published>2020-01-23T09:09:50.000Z</published>
    <updated>2020-06-24T10:39:34.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><a id="more"></a><h2 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h2><p>举个栗子吧=======================(* ￣3)(ε￣ *)======================</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> note <span class="keyword">struct</span>&#123;</span><br><span class="line">    content <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span>&#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p person)</span> <span class="title">WriteNote</span><span class="params">(n note)</span></span>&#123;</span><br><span class="line">    content = p.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1, p2 person</span><br><span class="line"><span class="keyword">var</span> n note <span class="comment">//note只有一本</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//p1想在note写写自己的名字</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    p1.WriteNote(n)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">//但是此时，p2也想在note上写写自己的名字</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    p2.WriteNote(n)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个goroutine的执行顺序没法保证</span></span><br><span class="line"><span class="comment">//所以p1，p2会争起来，而 n 就是竞争条件</span></span><br></pre></td></tr></table></figure><h2 id="解决方法1-足够多的note"><a href="#解决方法1-足够多的note" class="headerlink" title="解决方法1 足够多的note"></a>解决方法1 足够多的note</h2><blockquote><p>如果不是只有一个n，而是两个，三个，甚至更多，那么就没有争的必要了</p><p>(￣△￣；) ========== 废话=======================</p><p>现实是一般没有那么多的资源</p></blockquote><h2 id="解决方法2-绑定变量，顺序传递"><a href="#解决方法2-绑定变量，顺序传递" class="headerlink" title="解决方法2 绑定变量，顺序传递"></a>解决方法2 绑定变量，顺序传递</h2><blockquote><p>就像工厂的流水线一样，要加工的东西在第一个工人处完成第一步骤，传递到第二个工人处， 如此循环往复，中间不会出现步骤混乱的情况</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//就像下面加工cake的栗子============Σ(っ °Д °;)っ===================</span></span><br><span class="line"><span class="keyword">type</span> Cake <span class="keyword">struct</span>&#123;</span><br><span class="line">    state <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">baker</span><span class="params">(cooked <span class="keyword">chan</span>&lt;- *Cake)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>&#123;</span><br><span class="line">        cake := <span class="built_in">new</span>(Cake)</span><br><span class="line">        cake.state = <span class="string">"cooked"</span></span><br><span class="line">        cooked &lt;- cake <span class="comment">//烤蛋糕的人绝不会再碰这个蛋糕</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">icer</span><span class="params">(iced <span class="keyword">chan</span>&lt;- *Cake, cooked <span class="keyword">chan</span>&lt;- *cake)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> cake := <span class="keyword">range</span> cooked&#123;</span><br><span class="line">        cake.state = <span class="string">"Iced"</span></span><br><span class="line">        iced &lt;- cake <span class="comment">//加奶油的也不会再碰这个蛋糕</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//就像这样，一个cake虽然会在多个goroutine走过，但每次只有一个goroutine会拿到cake</span></span><br></pre></td></tr></table></figure><h2 id="解决方法3-互斥，加锁"><a href="#解决方法3-互斥，加锁" class="headerlink" title="解决方法3 互斥，加锁"></a>解决方法3 互斥，加锁</h2><blockquote><p>然而很多情况下没办法像流水线那样一步步的来，就像p1和p2， 谁来决定谁先写呢，这个时候就需要互斥，加锁了</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"><span class="comment">//就像这样，谁先抢到谁先写，写的过程中，别人无法进入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p person)</span> <span class="title">Write</span><span class="params">(n note)</span></span>&#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">    n.content = p.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>PS：注意这里mu.Lock()保护的Write方法只能被一个Goroutine访问，而不是保护note n</p><p>PS：Go不能重入锁，例如这里Write有mu.Lock()了，不能在里面再次调用mu.Lock(), 调用的方法里也不可以有mu.Lock()</p></blockquote><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><blockquote><p>有些时候，我们可能需要大量的读取，而不需要写入，或者有时只需要写入，不需要读取，那么就可以用读写锁</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.RWMutex</span><br><span class="line"><span class="comment">//这里多个读取操作不会有什么问题，但是写操作会互斥</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p person)</span> <span class="title">Read</span><span class="params">(n note)</span></span>&#123;</span><br><span class="line">    mu.RLock()</span><br><span class="line">    <span class="keyword">defer</span> mu.RUnlock()</span><br><span class="line">    <span class="keyword">return</span> n.content</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>RWMutex只有当获得锁的大部分goroutine都是读操作，而锁在竞争条件下， 也就是groutine必须等待才能获取锁的时候，RWMutex才能带来好处。一般情况下，因为RWMutex需要更加复杂的内部记录，因而比一般的无竞争锁的mutex更慢</p></blockquote><h2 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h2><blockquote><p>有些时候，我们需要初始化共享变量，但只需要初始化一遍，这时，就可以使用sync.Once</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> load sync.Once</span><br><span class="line"><span class="keyword">var</span> note <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetNote</span><span class="params">(<span class="keyword">string</span> k)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    load.Do(LoadNote(&amp;note)) <span class="comment">// 只会执行一次</span></span><br><span class="line">    <span class="keyword">return</span> note[k]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="竞争条件检测"><a href="#竞争条件检测" class="headerlink" title="竞争条件检测"></a>竞争条件检测</h2><blockquote><p>go 的一个工具</p><p>在go build， go run， go test命令后加上 -race的flag，编译器就会创建一个程序的修改版，能记录所有运行时期对共享变量访问工具的test</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;并发编程&quot;&gt;&lt;a href=&quot;#并发编程&quot; class=&quot;headerlink&quot; title=&quot;并发编程&quot;&gt;&lt;/a&gt;并发编程&lt;/h1&gt;
    
    </summary>
    
    
      <category term="go" scheme="https://mxuanp.github.io/categories/go/"/>
    
    
      <category term="go" scheme="https://mxuanp.github.io/tags/go/"/>
    
      <category term="golang" scheme="https://mxuanp.github.io/tags/golang/"/>
    
      <category term="并发编程" scheme="https://mxuanp.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>go-basic-goroutine-channel</title>
    <link href="https://mxuanp.github.io/2019/12/17/go-basic-goroutine-channel/"/>
    <id>https://mxuanp.github.io/2019/12/17/go-basic-goroutine-channel/</id>
    <published>2019-12-17T06:03:00.000Z</published>
    <updated>2020-06-24T10:38:40.220Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Goroutines-和-Channel"><a href="#Goroutines-和-Channel" class="headerlink" title="Goroutines 和 Channel"></a>Goroutines 和 Channel</h1><blockquote><p>这里只是记录go的goroutine和channel的基础用法,多线程有风险，用之需谨慎。。。。ヾ(＠⌒ー⌒＠)ノ。。。==========</p></blockquote><a id="more"></a><h1 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h1><h2 id="使用方法，，，，很简单的，，，，-＠￣ー￣＠"><a href="#使用方法，，，，很简单的，，，，-＠￣ー￣＠" class="headerlink" title="使用方法，，，，很简单的，，，，(＠￣ー￣＠)"></a>使用方法，，，，很简单的，，，，(＠￣ー￣＠)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用关键字go 后跟一个函数或方法，这个函数就会在新的goroutine中运行</span></span><br><span class="line"><span class="keyword">go</span> test()</span><br></pre></td></tr></table></figure><p>来个小栗子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//弄个动画小图标</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> spinner(<span class="number">100</span> * time.Millisecond)</span><br><span class="line"><span class="keyword">const</span> n = <span class="number">45</span></span><br><span class="line">fibN := fib(n)</span><br><span class="line">fmt.Printf(<span class="string">"\rFibonacci(%d) = %d\n"</span>, n, fibN)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spinner</span><span class="params">(delay time.Duration)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">`-\|/`</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"\r%c"</span>, r)</span><br><span class="line">time.Sleep(delay)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fib(x<span class="number">-1</span>) + fib(x<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>PS : main函数结束后，所有goroutine都会被直接打断，程序退出。除了主函数退出，或程序直接被终止，以及goroutine自行停止，没有其它编程方法能停止一个goroutine</p></blockquote><h2 id="例子：并发的Clock"><a href="#例子：并发的Clock" class="headerlink" title="例子：并发的Clock"></a>例子：并发的Clock</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//clock</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">"net"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">listener, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"localhost:8000"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">conn, err := listener.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Print(err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">handleConn(conn)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConn</span><span class="params">(conn net.Conn)</span></span>  &#123;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">_, err := io.WriteString(conn, time.Now().Format(<span class="string">"15:04:05\n"</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以看出，这个服务器一次只能接受一个连接，，</p><p>可以用nc之类的工具连接看结果</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并发的clock</span></span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">conn, err := listener.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Print(err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//只要这里加个go就行了</span></span><br><span class="line"><span class="keyword">go</span> handleConn(conn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例子：并发的Echo"><a href="#例子：并发的Echo" class="headerlink" title="例子：并发的Echo"></a>例子：并发的Echo</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接来个简单的echo</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConn</span><span class="params">(c net.Conn)</span></span>&#123;</span><br><span class="line">    io.Copy(c, c)</span><br><span class="line">    c.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//来个复杂点的</span></span><br><span class="line"><span class="comment">//回响echo，，大写到小写。。。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConn</span><span class="params">(c net.Conn)</span></span> &#123;</span><br><span class="line">input := bufio.NewScanner(c)</span><br><span class="line"><span class="keyword">for</span> input.Scan() &#123;</span><br><span class="line">echo(c, input.Text(), <span class="number">1</span>*time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">echo</span><span class="params">(c net.Conn, shout <span class="keyword">string</span>, delay time.Duration)</span></span> &#123;</span><br><span class="line">fmt.Fprintln(c, <span class="string">"\t"</span>, strings.ToUpper(shout))</span><br><span class="line">time.Sleep(delay)</span><br><span class="line">fmt.Fprintln(c, <span class="string">"\t"</span>, shout)</span><br><span class="line">time.Sleep(delay)</span><br><span class="line">fmt.Fprintln(c, <span class="string">"\t"</span>, strings.ToLower(shout))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1><blockquote><p>Channel实在goroutine之间的通信机制，她可以一个goroutine通过她向另一个goroutine发送消息</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="comment">//这样，一个可以发送int的channel就创建好了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//发送消息到channel</span></span><br><span class="line">ch &lt;- x</span><br><span class="line"></span><br><span class="line"><span class="comment">//从channel接收消息</span></span><br><span class="line">x := &lt;-ch</span><br><span class="line"><span class="comment">//关闭channel</span></span><br><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure><h3 id="不带缓存的Channel"><a href="#不带缓存的Channel" class="headerlink" title="不带缓存的Channel"></a>不带缓存的Channel</h3><blockquote><p>ch := make(chan int) 这样就声明初始化了一个不带缓存的Channel，不带缓存的Channel在执行发送操作后会堵塞发送者的goroutine， 直到发送的值被接收，相反，如果有goroutine在执行接收操作，也会堵塞，直到发送方向Channel发送数据</p></blockquote><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><blockquote><p>用channel来同步goroutine的工作，让主goroutine等待后台goroutine完成工作</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//netcat第一版，就是网络版cat</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"log"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"os"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"io"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"localhost:8000"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">io.Copy(os.Stdout, conn)</span><br><span class="line">log.Println(<span class="string">"done"</span>)</span><br><span class="line">done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;()</span><br><span class="line">mustCopy(conn, os.Stdin)</span><br><span class="line">conn.Close()</span><br><span class="line">&lt;- done</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mustCopy</span><span class="params">(dst io.Writer, src io.Reader)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> _, err := io.Copy(dst, src); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="串联的Channel（Pipeline）。。。就是管道。。。━━-￣ー￣-━━"><a href="#串联的Channel（Pipeline）。。。就是管道。。。━━-￣ー￣-━━" class="headerlink" title="串联的Channel（Pipeline）。。。就是管道。。。━━(￣ー￣*|||━━"></a>串联的Channel（Pipeline）。。。就是管道。。。━━(￣ー￣*|||━━</h2><blockquote><p>用Channel将多个goroutine连接起来</p></blockquote><img src= "/img/loading.gif" data-src="/2019/12/17/go-basic-goroutine-channel/go-pipe.png" class="" title="管道"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//管道</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//串串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">naturals := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">squares := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> x := <span class="number">0</span>; x&lt;<span class="number">100</span> ; x++ &#123;</span><br><span class="line">naturals &lt;- x</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">x, ok := &lt;-naturals</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">squares &lt;- x * x</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(squares)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(&lt;-squares)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Channel在没有被引用后会被Go的gc回收，所以可以不用手动关闭</p><p>和文件不同，文件不用后一定要手动调用对应的Close方法，否则后造成内存泄漏，资源的耗费</p></blockquote><h2 id="单方向Channel"><a href="#单方向Channel" class="headerlink" title="单方向Channel"></a>单方向Channel</h2><blockquote><p>即只能接收，或只能发送的Channel</p><p>双方向的Channel可以转换为单方向的Channel，但不可以将单方向的Channel转换为双方向的或转换为另一个方向</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)<span class="comment">//这样声明一个只能接收int的Channel</span></span><br><span class="line"></span><br><span class="line">ch := <span class="built_in">make</span>(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)<span class="comment">//这样声明一个只能发送int的Channel</span></span><br></pre></td></tr></table></figure><p>举个栗子。。。。。。o(<em>^▽^</em>)┛。。。。。。。。。。。。。。=======</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//管道</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">naturals := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">squares := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="comment">//包含了隐式转换</span></span><br><span class="line"><span class="keyword">go</span> counter(naturals)</span><br><span class="line"><span class="keyword">go</span> squarer(squares, naturals)</span><br><span class="line">printer(squares)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counter</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> x := <span class="number">0</span>; x &lt;= <span class="number">100</span>; x++ &#123;</span><br><span class="line">out &lt;- x</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squarer</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> in &#123;</span><br><span class="line">out &lt;- v * v</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> in &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="带缓存的Channel"><a href="#带缓存的Channel" class="headerlink" title="带缓存的Channel"></a>带缓存的Channel</h2><blockquote><p>带缓存的Channel内部持有一个元素的队列，队列的最大容量在make时指定</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">3</span>)<span class="comment">//这样就声明初始化了一个带缓存的Channel，缓存容量为3</span></span><br></pre></td></tr></table></figure><blockquote><p>向有缓存的Channel发送数据，直到Channel的缓存占满为止，发送操作不会阻塞goroutine</p><p>可以使用内置函数cap查看Channel的容量，内置函数len查看Channel的缓存区的数据量</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="built_in">cap</span>(ch))<span class="comment">//查看容量</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(ch))<span class="comment">//查看数据量</span></span><br></pre></td></tr></table></figure><h2 id="看一个栗子：。。。。-。・∀・-ノ。。。。。"><a href="#看一个栗子：。。。。-。・∀・-ノ。。。。。" class="headerlink" title="看一个栗子：。。。。(。・∀・)ノ。。。。。========"></a>看一个栗子：。。。。(。・∀・)ノ。。。。。========</h2><blockquote><p>这个栗子请求反应最快的镜像，并打印</p><p>如果使用无缓存的Channel，那么将有两个groutines没有接收而被卡住，这种情况称为goroutines泄漏，BUG。和有垃圾变量不一样，泄漏的groutine是无法被gc回收的，因此确保每个不再需要的goroutine能正常退出是很重要的 </p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mirroredQuery</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line">    resp := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;resp &lt;- request(<span class="string">"asia.gopl.io"</span>)&#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;resp &lt;- request(<span class="string">"europe.gopl.io"</span>)&#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;resp &lt;- request(<span class="string">"americas.gopl.io"</span>)&#125;()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">request</span><span class="params">()</span></span>&#123;</span><br><span class="line">    .........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>关于goroutines和Channel,可以想象一下工厂生产线</p></blockquote><h2 id="来弄个爬虫。。。。-━━-￣ー￣-━━。。。。。。。。。。。。"><a href="#来弄个爬虫。。。。-━━-￣ー￣-━━。。。。。。。。。。。。" class="headerlink" title="来弄个爬虫。。。。====━━(￣ー￣*|||━━。。。。。。。。。。。。"></a>来弄个爬虫。。。。====━━(￣ー￣*|||━━。。。。。。。。。。。。</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"gopl.io/ch5/links"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">worklist := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;worklist &lt;- os.Args[<span class="number">1</span>:]&#125;()</span><br><span class="line"><span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line">n++</span><br><span class="line">seen := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line"><span class="keyword">for</span> ;n&gt;<span class="number">0</span>;n--&#123;</span><br><span class="line">list := &lt;- worklist</span><br><span class="line"><span class="keyword">for</span> _,link := <span class="keyword">range</span> list&#123;</span><br><span class="line"><span class="keyword">if</span>(!seen[link])&#123;</span><br><span class="line">seen[link]=<span class="literal">true</span></span><br><span class="line">n++</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(link <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">worklist &lt;- crawl(link)</span><br><span class="line">&#125;(link)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> tokens = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">20</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">crawl</span><span class="params">(url <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">fmt.Println(url)</span><br><span class="line">tokens &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">list, err := links.Extract(url)</span><br><span class="line">&lt;-tokens</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Print(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><blockquote><p>go的select和switch类似，但是每个case必须是通信操作，发送或接收</p><p>PS：在select中是nil的channel永远不会被select到，因而可以使用nil激活或禁用case</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch1:</span><br><span class="line">    <span class="comment">//.........</span></span><br><span class="line">    <span class="keyword">case</span> x:=&lt;-ch2:</span><br><span class="line">    <span class="comment">//.........</span></span><br><span class="line">    <span class="keyword">case</span> ch3&lt;-y:</span><br><span class="line">    <span class="comment">//.........</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">//.........</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="轮询Channel"><a href="#轮询Channel" class="headerlink" title="轮询Channel"></a>轮询Channel</h2><blockquote><p>有时候需要从Channel接收值或发送，但又不能堵塞，特别是Channel没有准备好读写时，select就可以实现这样的功能，select的default可以用来设置当其它的操作都不能马上被处理时，执行的逻辑</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-abort:</span><br><span class="line">    fmt.Println(<span class="string">"Launch abort"</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    ........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Goroutines和线程"><a href="#Goroutines和线程" class="headerlink" title="Goroutines和线程"></a>Goroutines和线程</h2><h3 id="动态栈"><a href="#动态栈" class="headerlink" title="动态栈"></a>动态栈</h3><blockquote><p>每个OS线程都有一个固定的内存块(一般是2MB)作为栈， 但是2MB对一个Goroutine实在有些大，且固定大小的栈不方便修改。Goroutine以一个小的栈开始，一般只需要2KB， 且会根据需要动态地伸缩，最大值为1GB，当然，大多数时候不需要这么的栈</p></blockquote><h3 id="Goroutine调度"><a href="#Goroutine调度" class="headerlink" title="Goroutine调度"></a>Goroutine调度</h3><blockquote><p>Go有自己的运行时调度，例如n：m调度，这种调度，不是系统级的，因而Goroutine的调度代价比调度线程小的多</p></blockquote><h4 id="GOMAXPROCS"><a href="#GOMAXPROCS" class="headerlink" title="GOMAXPROCS"></a>GOMAXPROCS</h4><blockquote><p>Go的调度器使用GOMAXPROCS的环境变量来决定会有多少个操作系统的线程来调度</p><p>所以可以使用GOMACPROCS这个环境变量来显示地控制</p></blockquote><h2 id="Goroutine没有ID号"><a href="#Goroutine没有ID号" class="headerlink" title="Goroutine没有ID号"></a>Goroutine没有ID号</h2><blockquote><p>大多数支持多线程的操作系统和语言中，当前线程会有一个独特的身份（id），但是Groutine是没有的，且是设计上故意没有的，怕thread-locale storage 被滥用</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Goroutines-和-Channel&quot;&gt;&lt;a href=&quot;#Goroutines-和-Channel&quot; class=&quot;headerlink&quot; title=&quot;Goroutines 和 Channel&quot;&gt;&lt;/a&gt;Goroutines 和 Channel&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;这里只是记录go的goroutine和channel的基础用法,多线程有风险，用之需谨慎。。。。ヾ(＠⌒ー⌒＠)ノ。。。==========&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="go" scheme="https://mxuanp.github.io/categories/go/"/>
    
    
      <category term="go" scheme="https://mxuanp.github.io/tags/go/"/>
    
      <category term="golang" scheme="https://mxuanp.github.io/tags/golang/"/>
    
      <category term="go-basic" scheme="https://mxuanp.github.io/tags/go-basic/"/>
    
      <category term="goroutine" scheme="https://mxuanp.github.io/tags/goroutine/"/>
    
      <category term="go-channel" scheme="https://mxuanp.github.io/tags/go-channel/"/>
    
  </entry>
  
  <entry>
    <title>回锅香辣猪蹄</title>
    <link href="https://mxuanp.github.io/2019/12/16/%E5%9B%9E%E9%94%85%E9%A6%99%E8%BE%A3%E7%8C%AA%E8%B9%84/"/>
    <id>https://mxuanp.github.io/2019/12/16/%E5%9B%9E%E9%94%85%E9%A6%99%E8%BE%A3%E7%8C%AA%E8%B9%84/</id>
    <published>2019-12-16T13:54:27.000Z</published>
    <updated>2020-06-24T10:39:57.988Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回锅香辣猪蹄-是菜谱喔。。～-￣▽￣～-～￣▽￣-～"><a href="#回锅香辣猪蹄-是菜谱喔。。～-￣▽￣～-～￣▽￣-～" class="headerlink" title="回锅香辣猪蹄..===是菜谱喔。。～(￣▽￣～)(～￣▽￣)～"></a>回锅香辣猪蹄..===是菜谱喔。。～(￣▽￣～)(～￣▽￣)～</h1><blockquote><p>猪蹄，真香。。。。=============︿(￣︶￣)︿=====</p></blockquote><a id="more"></a><blockquote><ol><li>2个八角、2片香叶、少许桂皮、2瓣大蒜、3根干辣椒和3片姜，装入料包内备用。</li><li>2只猪蹄洗净，仔细刮毛（我还会用喷枪把表面烧一烧），冷水入锅，焯水后捞出。2根蒜苗洗净切成约3cm长的小段，1勺豆豉切碎，2片姜切末备用。</li><li>焯水后的猪蹄放入高压锅中，加入没过食材的水、料包、2勺料酒，加盖开大火焖煮30左右捞出，稍微放凉后用刀拆成小块。<br> *没有高压锅的，大火煮开后转小火煮1小时左右，筷子能轻松戳穿即可。</li><li>热锅冷油，放入豆豉和2勺郫县豆瓣酱炒出红油，再放入姜末翻炒片刻。</li><li>放入猪蹄炒匀，放入4勺老抽、2勺糖和少许盐翻炒匀，再加入蒜苗炒匀，出锅。</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;回锅香辣猪蹄-是菜谱喔。。～-￣▽￣～-～￣▽￣-～&quot;&gt;&lt;a href=&quot;#回锅香辣猪蹄-是菜谱喔。。～-￣▽￣～-～￣▽￣-～&quot; class=&quot;headerlink&quot; title=&quot;回锅香辣猪蹄..===是菜谱喔。。～(￣▽￣～)(～￣▽￣)～&quot;&gt;&lt;/a&gt;回锅香辣猪蹄..===是菜谱喔。。～(￣▽￣～)(～￣▽￣)～&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;猪蹄，真香。。。。=============︿(￣︶￣)︿=====&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="chef" scheme="https://mxuanp.github.io/categories/chef/"/>
    
    
      <category term="life" scheme="https://mxuanp.github.io/tags/life/"/>
    
      <category term="猪蹄" scheme="https://mxuanp.github.io/tags/%E7%8C%AA%E8%B9%84/"/>
    
  </entry>
  
  <entry>
    <title>红烧羊肉煨面</title>
    <link href="https://mxuanp.github.io/2019/12/16/%E7%BA%A2%E7%83%A7%E7%BE%8A%E8%82%89%E7%85%A8%E9%9D%A2/"/>
    <id>https://mxuanp.github.io/2019/12/16/%E7%BA%A2%E7%83%A7%E7%BE%8A%E8%82%89%E7%85%A8%E9%9D%A2/</id>
    <published>2019-12-16T11:44:38.000Z</published>
    <updated>2020-06-24T10:40:13.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="红烧羊肉煨面-是菜谱啦-gt-▽-lt"><a href="#红烧羊肉煨面-是菜谱啦-gt-▽-lt" class="headerlink" title="红烧羊肉煨面====是菜谱啦==(&gt;▽&lt;)==="></a>红烧羊肉煨面====是菜谱啦==(&gt;▽&lt;)===</h1><blockquote><p>面面，开心。。。===嗯~ o(<em>￣▽￣</em>)o==============</p></blockquote><a id="more"></a><blockquote><p>源地址：冬天最暖的事：有人陪你吃上一碗【红烧羊肉煨面】<a href="https://www.bilibili.com/video/av78133760" target="_blank" rel="noopener">https://www.bilibili.com/video/av78133760</a></p></blockquote><blockquote><p>PS：用量可随个人口味和经验添加或减少</p><p>PS：炖羊肉用砂锅，，，，(っ*´Д`)っ====</p></blockquote><blockquote><ol><li>600g带皮羊腿肉切块，冷水入锅，煮沸焯水后捞出洗净备用。</li><li>3g花椒、4g桂皮、2g白芷、2个八角和4片香叶放入香料包扎口备用。</li><li>热锅冷油，先下4片姜、4瓣蒜和3段大葱爆香，再放入焯好水的羊肉翻炒片刻，倒入50g生抽、25g老抽、30g冰糖和15g料酒翻炒均匀。</li><li>锅中放入香料包和1.5L水，大火煮沸后转小火炖一个半小时。</li><li>羊肉快炖好前10分钟，另起一锅烧水，水沸后下面条，稍煮片刻，去除碱水后捞出。</li><li>开盖，取出香料包，放入面条小火煨3-5分钟左右。</li><li>关火，捞出面条放入碗中，放上羊肉块，淋入汤汁，撒些青蒜末。</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;红烧羊肉煨面-是菜谱啦-gt-▽-lt&quot;&gt;&lt;a href=&quot;#红烧羊肉煨面-是菜谱啦-gt-▽-lt&quot; class=&quot;headerlink&quot; title=&quot;红烧羊肉煨面====是菜谱啦==(&amp;gt;▽&amp;lt;)===&quot;&gt;&lt;/a&gt;红烧羊肉煨面====是菜谱啦==(&amp;gt;▽&amp;lt;)===&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;面面，开心。。。===嗯~ o(&lt;em&gt;￣▽￣&lt;/em&gt;)o==============&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="chef" scheme="https://mxuanp.github.io/categories/chef/"/>
    
    
      <category term="life" scheme="https://mxuanp.github.io/tags/life/"/>
    
      <category term="面" scheme="https://mxuanp.github.io/tags/%E9%9D%A2/"/>
    
  </entry>
  
  <entry>
    <title>番茄牛尾火锅</title>
    <link href="https://mxuanp.github.io/2019/12/16/%E7%95%AA%E8%8C%84%E7%89%9B%E5%B0%BE%E7%81%AB%E9%94%85/"/>
    <id>https://mxuanp.github.io/2019/12/16/%E7%95%AA%E8%8C%84%E7%89%9B%E5%B0%BE%E7%81%AB%E9%94%85/</id>
    <published>2019-12-16T10:52:47.000Z</published>
    <updated>2020-06-24T10:40:08.844Z</updated>
    
    <content type="html"><![CDATA[<h1 id="番茄牛肉火锅，这只是一份菜谱ヾ-≧O≦-〃嗷"><a href="#番茄牛肉火锅，这只是一份菜谱ヾ-≧O≦-〃嗷" class="headerlink" title="番茄牛肉火锅，这只是一份菜谱ヾ(≧O≦)〃嗷~"></a>番茄牛肉火锅，这只是一份菜谱ヾ(≧O≦)〃嗷~</h1><blockquote><p>火锅，烫，呼<del>~</del>。。(๑•̀ㅂ•́)و✧===========================</p></blockquote><a id="more"></a><blockquote><p>源地址：宣布一下，我有那个陪我一起吃火锅的人了！ <a href="https://www.bilibili.com/video/av78983748" target="_blank" rel="noopener">https://www.bilibili.com/video/av78983748</a></p></blockquote><h2 id="番茄牛尾火锅锅底"><a href="#番茄牛尾火锅锅底" class="headerlink" title="番茄牛尾火锅锅底"></a>番茄牛尾火锅锅底</h2><blockquote><ol><li>1斤牛尾洗净冷水入锅，加入4片姜片和2勺料酒焯水洗净备用。锅内倒入适量热水，放入牛尾，加入4段大葱段、2片香叶、4片姜、4瓣大蒜和1个葱结，大火烧开撇去浮沫，转小火慢炖大约2小时后捞出香料弃置，牛尾汤备用。</li><li>4个香菇切十字纹，半个洋葱切小丁，半根甜玉米切小段，5个番茄去蒂表面划十字，放入沸水锅中烫至番茄皮卷边，取出后去皮切成小丁。</li><li>热锅冷油下洋葱末爆香，倒入番茄丁炒匀，中火煮10分钟至其变为糊状。</li><li>将翻炒好的番茄丁倒入涮锅中，加入甜玉米段、鲜香菇和牛尾汤，加盖炖煮10分钟后加入适量盐调味，再放入50g新鲜番茄片。</li></ol></blockquote><h2 id="芝心虾丸"><a href="#芝心虾丸" class="headerlink" title="芝心虾丸"></a>芝心虾丸</h2><blockquote><ol><li>250g虾仁洗净去除虾线，剁成虾泥。加入1/2勺盐和1/8勺白胡椒粉搅拌上劲，再加入1勺葱白姜汁和1个蛋清，搅拌待虾肉均匀吸收后，加入1/2勺淀粉和2勺猪油再次拌匀，反复摔打使其上劲。</li><li>放入保鲜袋内冷冻半小时。</li><li>手上沾上水，取20g虾肉糜捏成浅口小碗状，放入3g左右芝士小块，收口搓圆，双手反复摔打（见视频），放入盘中。</li></ol></blockquote><h2 id="蛋饺"><a href="#蛋饺" class="headerlink" title="蛋饺"></a>蛋饺</h2><blockquote><ol><li>250g猪肉糜中加入1/2勺盐、1/2勺糖、1/8勺胡椒粉、3勺葱姜水和1/2勺生粉搅拌出粘性，最后加入1/2勺麻油搅拌均匀，放入冰箱冷藏3小时。<br> *加入马蹄口感更爽脆也更解腻，4个马蹄洗净去皮，用刀拍碎切成小粒与肉馅拌匀即可。</li><li>碗中打入4颗鸡蛋，加入1勺水淀粉和1勺食用油搅拌均匀备用。</li><li>汤勺在小火上加热，在勺内抹一层猪油，倒一点蛋液进去，慢慢转动勺子，让蛋液均匀铺满。</li><li>趁未完全凝固前，取适量肉馅，摆在蛋皮的中间偏上部分。用筷子轻轻揭起一边的皮，盖上另一边，将两边的蛋皮合拢贴合，贴合部分隔着勺子靠近火源，加速凝固。</li></ol></blockquote><h2 id="火锅蘸料-看个人口味-￣▽￣-≧︶≦"><a href="#火锅蘸料-看个人口味-￣▽￣-≧︶≦" class="headerlink" title="火锅蘸料(看个人口味)==( ￣▽￣)((≧︶≦)==============="></a>火锅蘸料(看个人口味)==( <em>￣▽￣)((≧︶≦</em>)===============</h2><blockquote><p>1勺香菜末+1勺蒜泥+1勺葱花+半勺小米辣碎+1勺花生碎+1勺泡椒牛肉酱+2勺醋+1勺麻油+1勺半蚝油</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;番茄牛肉火锅，这只是一份菜谱ヾ-≧O≦-〃嗷&quot;&gt;&lt;a href=&quot;#番茄牛肉火锅，这只是一份菜谱ヾ-≧O≦-〃嗷&quot; class=&quot;headerlink&quot; title=&quot;番茄牛肉火锅，这只是一份菜谱ヾ(≧O≦)〃嗷~&quot;&gt;&lt;/a&gt;番茄牛肉火锅，这只是一份菜谱ヾ(≧O≦)〃嗷~&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;火锅，烫，呼&lt;del&gt;~&lt;/del&gt;。。(๑•̀ㅂ•́)و✧===========================&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="chef" scheme="https://mxuanp.github.io/categories/chef/"/>
    
    
      <category term="life" scheme="https://mxuanp.github.io/tags/life/"/>
    
      <category term="火锅" scheme="https://mxuanp.github.io/tags/%E7%81%AB%E9%94%85/"/>
    
  </entry>
  
  <entry>
    <title>go-error</title>
    <link href="https://mxuanp.github.io/2019/12/13/go-error/"/>
    <id>https://mxuanp.github.io/2019/12/13/go-error/</id>
    <published>2019-12-13T06:11:10.000Z</published>
    <updated>2020-06-24T10:39:07.776Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go的Error"><a href="#Go的Error" class="headerlink" title="Go的Error"></a>Go的Error</h1><a id="more"></a><blockquote><p>直接来看下go error的定义</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The error built-in interface type is the conventional interface for</span></span><br><span class="line"><span class="comment">// representing an error condition, with the nil value representing no error.</span></span><br><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>go的error就是一个interface,只有一个需要实现的方法Error(),用于返回一个string,一般用于返回错误信息</p></blockquote><h2 id="创建一个error最简单的方法-￣ω￣-￣ω￣"><a href="#创建一个error最简单的方法-￣ω￣-￣ω￣" class="headerlink" title="创建一个error最简单的方法=======￣ω￣===============￣ω￣======="></a>创建一个error最简单的方法=======￣ω￣===============￣ω￣=======</h2><blockquote><p>使用errors.New()方法</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright 2011 The Go Authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style</span></span><br><span class="line"><span class="comment">// license that can be found in the LICENSE file.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Package errors implements functions to manipulate errors.</span></span><br><span class="line"><span class="keyword">package</span> errors</span><br><span class="line"></span><br><span class="line"><span class="comment">// New returns an error that formats as the given text.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;errorString&#123;text&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// errorString is a trivial implementation of error.</span></span><br><span class="line"><span class="keyword">type</span> errorString <span class="keyword">struct</span> &#123;</span><br><span class="line">s <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errorString)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> e.s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>现在go的error就是这么简单</p><p>errors包的Error()方法使用指针接收的原因是每次分配新的地址，以避免可能出现的与已有的错误撞车，，&lt;( ‵□′)───C＜─___-)||。。。。。。。。。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//栗子</span></span><br><span class="line">fmt.Println(erros.New(<span class="string">"EOF"</span>) == errors.New(<span class="string">"EOF"</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h1 id="Go的panic的一个坑"><a href="#Go的panic的一个坑" class="headerlink" title="Go的panic的一个坑"></a>Go的panic的一个坑</h1><blockquote><p>recover()必须在defer函数中运行</p></blockquote><blockquote><p>recover捕获的是祖父级调用时的异常， 直接调用是无效的， 必须是祖父级， 且只隔着一个栈帧</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">recover</span>() <span class="comment">//没用， 捕获不了下面的panic</span></span><br><span class="line">    <span class="built_in">panic</span>(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>直接defer recover也是没用的</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">recover</span>() <span class="comment">//没用</span></span><br><span class="line">    <span class="built_in">panic</span>(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>defer里的recover如果嵌套了， 也是没用的</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">recover</span>() <span class="comment">// 嵌套了， 捕获不了main的panic</span></span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="built_in">panic</span>(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>必须直接在defer中recover</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">recover</span>() <span class="comment">//这样就有效了</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="built_in">panic</span>(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Go的Error&quot;&gt;&lt;a href=&quot;#Go的Error&quot; class=&quot;headerlink&quot; title=&quot;Go的Error&quot;&gt;&lt;/a&gt;Go的Error&lt;/h1&gt;
    
    </summary>
    
    
      <category term="go" scheme="https://mxuanp.github.io/categories/go/"/>
    
    
      <category term="go" scheme="https://mxuanp.github.io/tags/go/"/>
    
      <category term="golang" scheme="https://mxuanp.github.io/tags/golang/"/>
    
      <category term="go-error" scheme="https://mxuanp.github.io/tags/go-error/"/>
    
  </entry>
  
</feed>
